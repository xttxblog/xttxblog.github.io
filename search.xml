<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深入理解 Java String 类型</title>
    <url>/2021/12/06/java-string/</url>
    <content><![CDATA[<h1 id="深入理解-Java-String-类型"><a href="#深入理解-Java-String-类型" class="headerlink" title="深入理解 Java String 类型"></a>深入理解 Java String 类型</h1><blockquote>
<p><strong>📦 本文以及示例源码已归档在 <a href="https://github.com/dunwu/javacore/">javacore</a></strong></p>
<p>String 类型可能是 Java 中应用最频繁的引用类型，但它的性能问题却常常被忽略。高效的使用字符串，可以提升系统的整体性能。当然，要做到高效使用字符串，需要深入了解其特性。</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->

<ul>
<li><a href="#1-string-%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7">1. String 的不可变性</a></li>
<li><a href="#2-string-%E7%9A%84%E6%80%A7%E8%83%BD%E8%80%83%E9%87%8F">2. String 的性能考量</a><ul>
<li><a href="#21-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5">2.1. 字符串拼接</a></li>
<li><a href="#22-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2">2.2. 字符串分割</a></li>
<li><a href="#23-stringintern">2.3. String.intern</a></li>
</ul>
</li>
<li><a href="#3-stringstringbufferstringbuilder-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">3. String、StringBuffer、StringBuilder 有什么区别</a></li>
<li><a href="#4-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">4. 参考资料</a></li>
</ul>
<!-- /TOC -->

<h2 id="1-String-的不可变性"><a href="#1-String-的不可变性" class="headerlink" title="1. String 的不可变性"></a>1. String 的不可变性</h2><p>我们先来看下 <code>String</code> 的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure>

<p><code>String</code> 类被 <code>final</code> 关键字修饰，表示<strong>不可继承 <code>String</code> 类</strong>。</p>
<p><code>String</code> 类的数据存储于 <code>char[]</code> 数组，这个数组被 <code>final</code> 关键字修饰，表示 <strong><code>String</code> 对象不可被更改</strong>。</p>
<p>为什么 Java 要这样设计？</p>
<p>（1）<strong>保证 String 对象安全性</strong>。避免 String 被篡改。</p>
<p>（2）<strong>保证 hash 值不会频繁变更</strong>。</p>
<p>（3）<strong>可以实现字符串常量池</strong>。通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如 <code>String str=&quot;abc&quot;;</code> 另一种是字符串变量通过 new 形式的创建，如 <code>String str = new String(&quot;abc&quot;)</code>。</p>
<p>使用第一种方式创建字符串对象时，JVM 首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。</p>
<p><code>String str = new String(&quot;abc&quot;)</code> 这种方式，首先在编译类文件时，<code>&quot;abc&quot;</code> 常量字符串将会放入到常量结构中，在类加载时，<code>&quot;abc&quot;</code> 将会在常量池中创建；其次，在调用 new 时，JVM 命令将会调用 <code>String</code> 的构造函数，同时引用常量池中的 <code>&quot;abc&quot;</code> 字符串，在堆内存中创建一个 <code>String</code> 对象；最后，str 将引用 <code>String</code> 对象。</p>
<h2 id="2-String-的性能考量"><a href="#2-String-的性能考量" class="headerlink" title="2. String 的性能考量"></a>2. String 的性能考量</h2><h3 id="2-1-字符串拼接"><a href="#2-1-字符串拼接" class="headerlink" title="2.1. 字符串拼接"></a>2.1. 字符串拼接</h3><p><strong>字符串常量的拼接，编译器会将其优化为一个常量字符串</strong>。</p>
<p>【示例】字符串常量拼接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 本行代码在 class 文件中，会被编译器直接优化为：</span></span><br><span class="line">    <span class="comment">// String str = &quot;abc&quot;;</span></span><br><span class="line">    String str = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字符串变量的拼接，编译器会优化成 <code>StringBuilder</code> 的方式</strong>。</p>
<p>【示例】字符串变量的拼接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 本行代码会被编译器优化为：</span></span><br><span class="line">        <span class="comment">// str = (new StringBuilder(String.valueOf(str))).append(i).toString();</span></span><br><span class="line">        str = str + i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，每次循环都会生成一个新的 <code>StringBuilder</code> 实例，同样也会降低系统的性能。</p>
<p>字符串拼接的正确方案：</p>
<ul>
<li>如果需要使用<strong>字符串拼接，应该优先考虑 <code>StringBuilder</code> 的 <code>append</code> 方法替代使用 <code>+</code> 号</strong>。</li>
<li>如果在并发编程中，<code>String</code> 对象的拼接涉及到线程安全，可以使用 <code>StringBuffer</code>。但是要注意，由于 <code>StringBuffer</code> 是线程安全的，涉及到锁竞争，所以从性能上来说，要比 <code>StringBuilder</code> 差一些。</li>
</ul>
<h3 id="2-2-字符串分割"><a href="#2-2-字符串分割" class="headerlink" title="2.2. 字符串分割"></a>2.2. 字符串分割</h3><p><strong><code>String</code> 的 <code>split()</code> 方法使用正则表达式实现其强大的分割功能</strong>。而正则表达式的性能是非常不稳定的，使用不恰当会引起回溯问题，很可能导致 CPU 居高不下。</p>
<p>所以，应该慎重使用 <code>split()</code> 方法，<strong>可以考虑用 <code>String.indexOf()</code> 方法代替 <code>split()</code> 方法完成字符串的分割</strong>。如果实在无法满足需求，你就在使用 Split() 方法时，对回溯问题加以重视就可以了。</p>
<h3 id="2-3-String-intern"><a href="#2-3-String-intern" class="headerlink" title="2.3. String.intern"></a>2.3. String.intern</h3><p><strong>在每次赋值的时候使用 <code>String</code> 的 <code>intern</code> 方法，如果常量池中有相同值，就会重复使用该对象，返回对象引用，这样一开始的对象就可以被回收掉</strong>。</p>
<p>在字符串常量中，默认会将对象放入常量池；在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，复制到堆内存对象中，并返回堆内存对象引用。</p>
<p>如果调用 <code>intern</code> 方法，会去查看字符串常量池中是否有等于该对象的字符串，如果没有，就在常量池中新增该对象，并返回该对象引用；如果有，就返回常量池中的字符串引用。堆内存中原有的对象由于没有引用指向它，将会通过垃圾回收器回收。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedLocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String city;</span><br><span class="line">	<span class="keyword">private</span> String region;</span><br><span class="line">	<span class="keyword">private</span> String countryCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SharedLocation sharedLocation = <span class="keyword">new</span> SharedLocation();</span><br><span class="line">sharedLocation.setCity(messageInfo.getCity().intern());		sharedLocation.setCountryCode(messageInfo.getRegion().intern());</span><br><span class="line">sharedLocation.setRegion(messageInfo.getCountryCode().intern());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <code>intern</code> 方法需要注意：一定要结合实际场景。因为常量池的实现是类似于一个 HashTable 的实现方式，HashTable 存储的数据越大，遍历的时间复杂度就会增加。如果数据过大，会增加整个字符串常量池的负担。</p>
</blockquote>
<h2 id="3-String、StringBuffer、StringBuilder-有什么区别"><a href="#3-String、StringBuffer、StringBuilder-有什么区别" class="headerlink" title="3. String、StringBuffer、StringBuilder 有什么区别"></a>3. String、StringBuffer、StringBuilder 有什么区别</h2><p><code>String</code> 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 <code>Immutable</code> 类，被声明成为 <code>final class</code>，所有属性也都是 <code>final</code> 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 <code>String</code> 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</p>
<p><code>StringBuffer</code> 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 <code>append</code> 或者 <code>add</code> 方法，把字符串添加到已有序列的末尾或者指定位置。<code>StringBuffer</code> 是一个<strong>线程安全的</strong>可修改字符序列。<code>StringBuffer</code> 的线程安全是通过在各种修改数据的方法上用 <code>synchronized</code> 关键字修饰实现的。</p>
<p><code>StringBuilder</code> 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。</p>
<p><code>StringBuffer</code> 和 <code>StringBuilder</code> 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 <code>AbstractStringBuilder</code>，里面包含了基本操作，区别仅在于最终的方法是否加了 <code>synchronized</code>。构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 <code>arraycopy</code>。</p>
<p>**除非有线程安全的需要，不然一般都使用 <code>StringBuilder</code>**。</p>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/2130190/">《Java 编程思想（Thinking in java）》</a></li>
<li><a href="https://book.douban.com/subject/26880667/">《Java 核心技术 卷 I 基础知识》</a></li>
<li><a href="https://time.geekbang.org/column/intro/100028001">《Java 性能调优实战》</a></li>
<li><a href="https://time.geekbang.org/column/intro/82">《Java 核心技术面试精讲》</a></li>
<li><a href="https://juejin.im/post/59cd71835188255d3448faf6">Java 基本数据类型和引用类型</a></li>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析 Java 中的装箱和拆箱</a></li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象</title>
    <url>/2021/12/06/java-oop/</url>
    <content><![CDATA[<h1 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h1><blockquote>
<p>在<a href="https://github.com/dunwu/blog/blob/master/source/_posts/programming/java/javacore/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md">深入理解 Java 基本数据类型</a>中我们了解 Java 中支持的基本数据类型（值类型）。本文开始讲解 Java 中重要的引用类型——类。</p>
<p><strong>📦 本文以及示例源码已归档在 <a href="https://github.com/dunwu/javacore/">javacore</a></strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->

<ul>
<li><a href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">1. 面向对象</a><ul>
<li><a href="#11-%E5%B0%81%E8%A3%85">1.1. 封装</a></li>
<li><a href="#12-%E7%BB%A7%E6%89%BF">1.2. 继承</a></li>
<li><a href="#13-%E5%A4%9A%E6%80%81">1.3. 多态</a></li>
</ul>
</li>
<li><a href="#2-%E7%B1%BB">2. 类</a></li>
<li><a href="#3-%E6%96%B9%E6%B3%95">3. 方法</a><ul>
<li><a href="#31-%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89">3.1. 方法定义</a></li>
<li><a href="#32-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">3.2. 方法调用</a></li>
<li><a href="#33-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">3.3. 构造方法</a></li>
</ul>
</li>
<li><a href="#4-%E5%8F%98%E9%87%8F">4. 变量</a><ul>
<li><a href="#41-%E5%8F%98%E9%87%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6">4.1. 变量修饰符</a></li>
<li><a href="#42-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">4.2. 创建对象</a></li>
<li><a href="#43-%E8%AE%BF%E9%97%AE%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95">4.3. 访问实例变量和方法</a></li>
</ul>
</li>
<li><a href="#5-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6">5. 访问权限控制</a><ul>
<li><a href="#51-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87">5.1. 代码组织</a></li>
<li><a href="#52-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E5%85%B3%E9%94%AE%E5%AD%97">5.2. 访问权限修饰关键字</a></li>
</ul>
</li>
<li><a href="#6-%E6%8E%A5%E5%8F%A3">6. 接口</a></li>
<li><a href="#7-%E6%8A%BD%E8%B1%A1%E7%B1%BB">7. 抽象类</a></li>
<li><a href="#8-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">8. 参考资料</a></li>
</ul>
<!-- /TOC -->

<h2 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1. 面向对象"></a>1. 面向对象</h2><p>每种编程语言，都有自己的操纵内存中元素的方式。</p>
<p>Java 中提供了<a href="https://github.com/dunwu/blog/blob/master/source/_posts/programming/java/javacore/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md">基本数据类型</a>，但这还不能满足编写程序时，需要抽象更加复杂数据类型的需要。因此，Java 中，允许开发者通过类（类的机制下面会讲到）创建自定义类型。</p>
<p>有了自定义类型，那么数据类型自然会千变万化，所以，必须要有一定的机制，使得它们仍然保持一些必要的、通用的特性。</p>
<p>Java 世界有一句名言：一切皆为对象。这句话，你可能第一天学 Java 时，就听过了。这不仅仅是一句口号，也体现在 Java 的设计上。</p>
<ul>
<li>首先，所有 Java 类都继承自 <code>Object</code> 类（从这个名字，就可见一斑）。</li>
<li>几乎所有 Java 对象初始化时，都要使用 <code>new</code> 创建对象（<a href="https://github.com/dunwu/blog/blob/master/source/_posts/programming/java/javacore/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md">基本数据类型</a>、String、枚举特殊处理），对象存储在堆中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面两</span></span><br><span class="line">String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>其中，<code>String s</code> 定义了一个名为 s 的引用，它指向一个 <code>String</code> 类型的对象，而实际的对象是 <code>“abc”</code> 字符串。这就像是，使用遥控器（引用）来操纵电视机（对象）。</p>
<p>与 C/C++ 这类语言不同，程序员只需要通过 <code>new</code> 创建一个对象，但不必负责销毁或结束一个对象。负责运行 Java 程序的 Java 虚拟机有一个垃圾回收器，它会监视 <code>new</code> 创建的对象，一旦发现对象不再被引用，则会释放对象的内存空间。</p>
<h3 id="1-1-封装"><a href="#1-1-封装" class="headerlink" title="1.1. 封装"></a>1.1. 封装</h3><p><strong>封装（Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。</strong></p>
<p>封装最主要的作用在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>
<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
<p>封装的优点：</p>
<ul>
<li>良好的封装能够减少耦合。</li>
<li>类内部的结构可以自由修改。</li>
<li>可以对成员变量进行更精确的控制。</li>
<li>隐藏信息，实现细节。</li>
</ul>
<p>实现封装的步骤：</p>
<ol>
<li>修改属性的可见性来限制对属性的访问（一般限制为 private）。</li>
<li>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问。</li>
</ol>
<h3 id="1-2-继承"><a href="#1-2-继承" class="headerlink" title="1.2. 继承"></a>1.2. 继承</h3><p>继承是 java 面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<p>现实中的例子：</p>
<p>狗和鸟都是动物。如果将狗、鸟作为类，它们可以继承动物类。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1552641712126.png" alt="img"></p>
<p>类的继承形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class 父类 &#123;&#125;</span><br><span class="line"></span><br><span class="line">class 子类 extends 父类 &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h4><p><img src="http://www.runoob.com/wp-content/uploads/2013/12/types_of_inheritance.png" alt="img"></p>
<h4 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h4><ul>
<li>子类拥有父类非 private 的属性、方法。</li>
<li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
<li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li>
<li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li>
</ul>
<h4 id="继承关键字"><a href="#继承关键字" class="headerlink" title="继承关键字"></a>继承关键字</h4><p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承 object（这个类在 <strong>java.lang</strong> 包中，所以不需要 <strong>import</strong>）祖先类。</p>
<h3 id="1-3-多态"><a href="#1-3-多态" class="headerlink" title="1.3. 多态"></a>1.3. 多态</h3><p>刚开始学习面向对象编程时，容易被各种术语弄得云里雾里。所以，很多人会死记硬背书中对于术语的定义。</p>
<p>但是，随着应用和理解的深入，应该会渐渐有更进一步的认识，将其融汇贯通的理解。</p>
<p>学习类之前，先让我们思考一个问题：Java 中为什么要引入类机制，设计的初衷是什么？</p>
<p>Java 中提供的基本数据类型，只能表示单一的数值，这用于数值计算，还 OK。但是，如果要抽象模拟现实中更复杂的事物，则无法做到。</p>
<p>试想，如果要让你抽象狗的数据模型，怎么做？狗有眼耳口鼻等器官，有腿，狗有大小，毛色，这些都是它的状态，狗会跑、会叫、会吃东西，这些是它的行为。</p>
<p>类的引入，就是为了抽象这种相对复杂的事物。</p>
<p>对象是用于计算机语言对问题域中事物的描述。<strong>对象通过方法和属性来分别描述事物所具有的行为和状态。</strong></p>
<p><strong>类是用于描述同一类的对象的一个抽象的概念，类中定义了这一类对象所具有的行为和状态。</strong></p>
<p>类可以看成是创建 Java 对象的模板。</p>
<p>什么是方法？扩展阅读：<a href="https://www.zhihu.com/question/20275578/answer/26577791">面向对象编程的弊端是什么？ - invalid s 的回答</a></p>
<h2 id="2-类"><a href="#2-类" class="headerlink" title="2. 类"></a>2. 类</h2><p>与大多数面向对象编程语言一样，Java 使用 <code>class</code> （类）关键字来表示自定义类型。自定义类型是为了更容易抽象现实事物。</p>
<p>在一个类中，可以设置一静一动两种元素：属性（静）和方法（动）。</p>
<ul>
<li><strong>属性（有的人喜欢称为成员、字段）</strong> - 属性抽象的是事物的状态。类属性可以是任何类型的对象。</li>
<li><strong>方法（有的人喜欢称为函数）</strong> - 方法抽象的是事物的行为。</li>
</ul>
<p>类的形式如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1552640231731.png" alt="img"></p>
<h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><h3 id="3-1-方法定义"><a href="#3-1-方法定义" class="headerlink" title="3.1. 方法定义"></a>3.1. 方法定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li><strong>修饰符：</strong>修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li><strong>返回值类型 ：</strong>方法可能有返回值。如果没有返回值，这种情况下，返回值类型应设为 void。</li>
<li><strong>方法名：</strong>是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li><strong>参数类型：</strong>参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li>
<li><strong>方法体：</strong>方法体包含具体的语句，定义该方法的功能。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-方法调用"><a href="#3-2-方法调用" class="headerlink" title="3.2. 方法调用"></a>3.2. 方法调用</h3><p>Java 支持两种调用方法的方式，根据方法是否返回值来选择。</p>
<p>当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。</p>
<p>当方法返回一个值的时候，方法调用通常被当做一个值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int larger = max(30, 40);</span><br></pre></td></tr></table></figure>

<p>如果方法返回值是 void，方法调用一定是一条语句。例如，方法 println 返回 void。下面的调用是个语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;Hello World&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-构造方法"><a href="#3-3-构造方法" class="headerlink" title="3.3. 构造方法"></a>3.3. 构造方法</h3><p>每个类都有构造方法。如果没有显式地为类定义任何构造方法，Java 编译器将会为该类提供一个默认构造方法。</p>
<p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puppy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Puppy</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这个构造器仅有一个参数：name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h2><p>Java 支持的变量类型有：</p>
<ul>
<li><code>局部变量</code> - 类方法中的变量。</li>
<li><code>实例变量（也叫成员变量）</code> - 类方法外的变量，不过没有 <code>static</code> 修饰。</li>
<li><code>类变量（也叫静态变量）</code> - 类方法外的变量，用 <code>static</code> 修饰。</li>
</ul>
<p>特性对比：</p>
<table>
<thead>
<tr>
<th>局部变量</th>
<th>实例变量（也叫成员变量）</th>
<th>类变量（也叫静态变量）</th>
</tr>
</thead>
<tbody><tr>
<td>局部变量声明在方法、构造方法或者语句块中。</td>
<td>实例变量声明在方法、构造方法和语句块之外。</td>
<td>类变量声明在方法、构造方法和语句块之外。并且以 static 修饰。</td>
</tr>
<tr>
<td>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。</td>
<td>实例变量在对象创建的时候创建，在对象被销毁的时候销毁。</td>
<td>类变量在第一次被访问时创建，在程序结束时销毁。</td>
</tr>
<tr>
<td>局部变量没有默认值，所以必须经过初始化，才可以使用。</td>
<td>实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。</td>
<td>类变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</td>
</tr>
<tr>
<td>对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。</td>
<td>实例变量存储在堆。</td>
<td>类变量存储在静态存储区。</td>
</tr>
<tr>
<td>访问修饰符不能用于局部变量。</td>
<td>访问修饰符可以用于实例变量。</td>
<td>访问修饰符可以用于类变量。</td>
</tr>
<tr>
<td>局部变量只在声明它的方法、构造方法或者语句块中可见。</td>
<td>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见。</td>
<td>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</td>
</tr>
<tr>
<td></td>
<td>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</td>
<td>静态变量可以通过：ClassName.VariableName 的方式访问。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>类变量除了被声明为常量外很少使用。</td>
</tr>
</tbody></table>
<h3 id="4-1-变量修饰符"><a href="#4-1-变量修饰符" class="headerlink" title="4.1. 变量修饰符"></a>4.1. 变量修饰符</h3><ul>
<li>访问级别修饰符 - 如果变量是实例变量或类变量，可以添加访问级别修饰符（public/protected/private）</li>
<li>静态修饰符 - 如果变量是类变量，需要添加 static 修饰</li>
<li>final - 如果变量使用 fianl 修饰符，就表示这是一个常量，不能被修改。</li>
</ul>
<h3 id="4-2-创建对象"><a href="#4-2-创建对象" class="headerlink" title="4.2. 创建对象"></a>4.2. 创建对象</h3><p>对象是根据类创建的。在 Java 中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p>
<ul>
<li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li>
<li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li>
<li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Puppy&#123;</span><br><span class="line">   public Puppy(String name)&#123;</span><br><span class="line">      //这个构造器仅有一个参数：name</span><br><span class="line">      System.out.println(&quot;小狗的名字是 : &quot; + name );</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">      // 下面的语句将创建一个Puppy对象</span><br><span class="line">      Puppy myPuppy = new Puppy( &quot;tommy&quot; );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-访问实例变量和方法"><a href="#4-3-访问实例变量和方法" class="headerlink" title="4.3. 访问实例变量和方法"></a>4.3. 访问实例变量和方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 实例化对象 */</span><br><span class="line">ObjectReference = new Constructor();</span><br><span class="line">/* 访问类中的变量 */</span><br><span class="line">ObjectReference.variableName;</span><br><span class="line">/* 访问类中的方法 */</span><br><span class="line">ObjectReference.methodName();</span><br></pre></td></tr></table></figure>

<h2 id="5-访问权限控制"><a href="#5-访问权限控制" class="headerlink" title="5. 访问权限控制"></a>5. 访问权限控制</h2><h3 id="5-1-代码组织"><a href="#5-1-代码组织" class="headerlink" title="5.1. 代码组织"></a>5.1. 代码组织</h3><p><strong>当编译一个 .java 文件时，在 .java 文件中的每个类都会输出一个与类同名的 .class 文件。</strong></p>
<p>MultiClassDemo.java 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiClass1</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiClass2</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiClass3</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiClassDemo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>javac MultiClassDemo.java</code> 命令，本地会生成 MultiClass1.class、MultiClass2.class、MultiClass3.class、MultiClassDemo.class 四个文件。</p>
<p><strong>Java 可运行程序是由一组 .class 文件打包并压缩成的一个 .jar 文件</strong>。Java 解释器负责这些文件的查找、装载和解释。<strong>Java 类库实际上是一组类文件（.java 文件）。</strong></p>
<ul>
<li><strong>其中每个文件允许有一个 public 类，以及任意数量的非 public 类</strong>。</li>
<li><strong>public 类名必须和 .java 文件名完全相同，包括大小写。</strong></li>
</ul>
<p>程序一般不止一个人编写，会调用系统提供的代码、第三方库中的代码、项目中其他人写的代码等，不同的人因为不同的目的可能定义同样的类名/接口名，这就是命名冲突。</p>
<p>Java 中为了解决命名冲突问题，提供了包（<code>package</code>）和导入（<code>import</code>）机制。</p>
<h4 id="package"><a href="#package" class="headerlink" title="package"></a>package</h4><p>包（<code>package</code>）的原则：</p>
<ul>
<li>包类似于文件夹，文件放在文件夹中，类和接口则放在包中。为了便于组织，文件夹一般是一个<strong>有层次的树形结构</strong>，包也类似。</li>
<li><strong>包名以逗号 <code>.</code> 分隔，表示层次结构。</strong></li>
<li>Java 中命名包名的一个惯例是使用域名作为前缀，因为域名是唯一的，一般按照域名的反序来定义包名，比如，域名是：apache.org，包名就以 org.apache 开头。</li>
<li><strong>包名和文件目录结构必须完全匹配。</strong>Java 解释器运行过程如下：<ul>
<li>找出环境变量 CLASSPATH，作为 .class 文件的根目录。</li>
<li>从根目录开始，获取包名称，并将逗号 <code>.</code> 替换为文件分隔符（反斜杠 <code>/</code>），通过这个路径名称去查找 Java 类。</li>
</ul>
</li>
</ul>
<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>同一个包下的类之间互相引用是不需要包名的，可以直接使用。但如果类不在同一个包内，则必须要知道其所在的包，使用有两种方式：</p>
<ul>
<li>通过类的完全限定名</li>
<li>通过 import 将用到的类引入到当前类</li>
</ul>
<p>通过类的完全限定名示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> java.util.Date());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> java.util.Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>import</code> 导入其它包的类到当前类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：以上两个示例比较起来，显然是 <code>import</code> 方式，代码更加整洁。</p>
</blockquote>
<blockquote>
<p>扩展阅读：<a href="https://www.cnblogs.com/swiftma/p/5628762.html">https://www.cnblogs.com/swiftma/p/5628762.html</a></p>
</blockquote>
<h3 id="5-2-访问权限修饰关键字"><a href="#5-2-访问权限修饰关键字" class="headerlink" title="5.2. 访问权限修饰关键字"></a>5.2. 访问权限修饰关键字</h3><p>访问权限控制的等级，从最大权限到最小权限依次为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public &gt; protected &gt; 包访问权限（没有任何关键字）&gt; private</span><br></pre></td></tr></table></figure>

<ul>
<li><code>public</code> - 表示任何类都可以访问；</li>
<li><code>包访问权限</code> - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。</li>
<li><code>protected</code> - 表示子类可以访问，此外，同一个包内的其他类也可以访问，即使这些类不是子类。</li>
<li><code>private</code> - 表示其它任何类都无法访问。</li>
</ul>
<h2 id="6-接口"><a href="#6-接口" class="headerlink" title="6. 接口"></a>6. 接口</h2><p>接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。</p>
<p>接口，不能实例化；不能包含任何非常量成员，任何 field 都是隐含着 <code>public static final</code> 的意义；同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。</p>
<p>Java 标准类库中，定义了非常多的接口，比如 <code>java.util.List</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-抽象类"><a href="#7-抽象类" class="headerlink" title="7. 抽象类"></a>7. 抽象类</h2><p>抽象类是不能实例化的类，用 <code>abstract</code> 关键字修饰 <code>class</code>，其目的主要是代码重用。除了不能实例化，形式上和一般的 Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。</p>
<p>Java 标准库中，比如 <code>collection</code> 框架，很多通用部分就被抽取成为抽象类，例如 <code>java.util.AbstractList</code>。</p>
<ol>
<li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li>
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li>
<li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li>
</ol>
<h2 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8. 参考资料"></a>8. 参考资料</h2><ul>
<li>书籍<ul>
<li><a href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
<li><a href="https://book.douban.com/subject/4496038/">Head First Java</a></li>
</ul>
</li>
<li>文章<ul>
<li><a href="https://www.zhihu.com/question/20275578/answer/26577791">面向对象编程的弊端是什么？ - invalid s 的回答</a></li>
<li><a href="https://www.cnblogs.com/swiftma/p/5628762.html">https://www.cnblogs.com/swiftma/p/5628762.html</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>oop</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java 反射和动态代理</title>
    <url>/2021/12/06/java-reflection/</url>
    <content><![CDATA[<h1 id="深入理解-Java-反射和动态代理"><a href="#深入理解-Java-反射和动态代理" class="headerlink" title="深入理解 Java 反射和动态代理"></a>深入理解 Java 反射和动态代理</h1><blockquote>
<p><strong>📦 本文以及示例源码已归档在 <a href="https://github.com/dunwu/javacore/">javacore</a></strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->

<ul>
<li><a href="#1-%E5%8F%8D%E5%B0%84%E7%AE%80%E4%BB%8B">1. 反射简介</a><ul>
<li><a href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84">1.1. 什么是反射</a></li>
<li><a href="#12-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">1.2. 反射的应用场景</a></li>
<li><a href="#13-%E5%8F%8D%E5%B0%84%E7%9A%84%E7%BC%BA%E7%82%B9">1.3. 反射的缺点</a></li>
</ul>
</li>
<li><a href="#2-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6">2. 反射机制</a><ul>
<li><a href="#21-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B">2.1. 类加载过程</a></li>
<li><a href="#22-class-%E5%AF%B9%E8%B1%A1">2.2. Class 对象</a></li>
<li><a href="#23-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8">2.3. 方法的反射调用</a></li>
<li><a href="#24-%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8%E7%9A%84%E5%BC%80%E9%94%80">2.4. 反射调用的开销</a></li>
</ul>
</li>
<li><a href="#3-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84">3. 使用反射</a><ul>
<li><a href="#31-javalangreflect-%E5%8C%85">3.1. java.lang.reflect 包</a></li>
<li><a href="#32-%E8%8E%B7%E5%8F%96-class-%E5%AF%B9%E8%B1%A1">3.2. 获取 Class 对象</a></li>
<li><a href="#33-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B">3.3. 判断是否为某个类的实例</a></li>
<li><a href="#34-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B">3.4. 创建实例</a></li>
<li><a href="#35-%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B">3.5. 创建数组实例</a></li>
<li><a href="#36-field">3.6. Field</a></li>
<li><a href="#37-method">3.7. Method</a></li>
<li><a href="#38-constructor">3.8. Constructor</a></li>
<li><a href="#39-%E7%BB%95%E5%BC%80%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6">3.9. 绕开访问限制</a></li>
</ul>
</li>
<li><a href="#4-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">4. 动态代理</a><ul>
<li><a href="#41-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86">4.1. 静态代理</a></li>
<li><a href="#42-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">4.2. JDK 动态代理</a></li>
<li><a href="#43-cglib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">4.3. CGLIB 动态代理</a></li>
</ul>
</li>
<li><a href="#5-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">5. 参考资料</a></li>
</ul>
<!-- /TOC -->

<h2 id="1-反射简介"><a href="#1-反射简介" class="headerlink" title="1. 反射简介"></a>1. 反射简介</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/Java%E5%8F%8D%E5%B0%84.svg" alt="img"></p>
<h3 id="1-1-什么是反射"><a href="#1-1-什么是反射" class="headerlink" title="1.1. 什么是反射"></a>1.1. 什么是反射</h3><p>反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p>
<p><strong>通过反射机制，可以在运行时访问 Java 对象的属性，方法，构造方法等。</strong></p>
<h3 id="1-2-反射的应用场景"><a href="#1-2-反射的应用场景" class="headerlink" title="1.2. 反射的应用场景"></a>1.2. 反射的应用场景</h3><p>反射的主要应用场景有：</p>
<ul>
<li><strong>开发通用框架</strong> - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</li>
<li><strong>动态代理</strong> - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</li>
<li><strong>注解</strong> - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。</li>
<li><strong>可扩展性功能</strong> - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。</li>
</ul>
<h3 id="1-3-反射的缺点"><a href="#1-3-反射的缺点" class="headerlink" title="1.3. 反射的缺点"></a>1.3. 反射的缺点</h3><ul>
<li><strong>性能开销</strong> - 由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。</li>
<li><strong>破坏封装性</strong> - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</li>
<li><strong>内部曝光</strong> - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。</li>
</ul>
<h2 id="2-反射机制"><a href="#2-反射机制" class="headerlink" title="2. 反射机制"></a>2. 反射机制</h2><h3 id="2-1-类加载过程"><a href="#2-1-类加载过程" class="headerlink" title="2.1. 类加载过程"></a>2.1. 类加载过程</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1553611895164.png" alt="img"></p>
<p>类加载的完整过程如下：</p>
<ol>
<li>在编译时，Java 编译器编译好 <code>.java</code> 文件之后，在磁盘中产生 <code>.class</code> 文件。<code>.class</code> 文件是二进制文件，内容是只有 JVM 能够识别的机器码。</li>
<li>JVM 中的类加载器读取字节码文件，取出二进制数据，加载到内存中，解析.class 文件内的信息。类加载器会根据类的全限定名来获取此类的二进制字节流；然后，将字节流所代表的静态存储结构转化为方法区的运行时数据结构；接着，在内存中生成代表这个类的 <code>java.lang.Class</code> 对象。</li>
<li>加载结束后，JVM 开始进行连接阶段（包含验证、准备、初始化）。经过这一系列操作，类的变量会被初始化。</li>
</ol>
<h3 id="2-2-Class-对象"><a href="#2-2-Class-对象" class="headerlink" title="2.2. Class 对象"></a>2.2. Class 对象</h3><p>要想使用反射，首先需要获得待操作的类所对应的 Class 对象。<strong>Java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 Class 对象。这个 Class 对象是由 JVM 生成的，通过它能够获悉整个类的结构</strong>。所以，<code>java.lang.Class</code> 可以视为所有反射 API 的入口点。</p>
<p><strong>反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。</strong></p>
<p>举例来说，假如定义了以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>

<p>步骤说明：</p>
<ol>
<li>JVM 加载方法的时候，遇到 <code>new User()</code>，JVM 会根据 <code>User</code> 的全限定名去加载 <code>User.class</code> 。</li>
<li>JVM 会去本地磁盘查找 <code>User.class</code> 文件并加载 JVM 内存中。</li>
<li>JVM 通过调用类加载器自动创建这个类对应的 <code>Class</code> 对象，并且存储在 JVM 的方法区。注意：<strong>一个类有且只有一个 <code>Class</code> 对象</strong>。</li>
</ol>
<h3 id="2-3-方法的反射调用"><a href="#2-3-方法的反射调用" class="headerlink" title="2.3. 方法的反射调用"></a>2.3. 方法的反射调用</h3><p>方法的反射调用，也就是 <code>Method.invoke</code> 方法。</p>
<p><code>Method.invoke</code> 方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> <span class="keyword">extends</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> ... </span>&#123;</span><br><span class="line">    ... <span class="comment">// 权限检查</span></span><br><span class="line">    MethodAccessor ma = methodAccessor;</span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Method.invoke</code> 方法实际上委派给 <code>MethodAccessor</code> 接口来处理。它有两个已有的具体实现：</p>
<ul>
<li><code>NativeMethodAccessorImpl</code>：本地方法来实现反射调用</li>
<li><code>DelegatingMethodAccessorImpl</code>：委派模式来实现反射调用</li>
</ul>
<p>每个 <code>Method</code> 实例的第一次反射调用都会生成一个委派实现（<code>DelegatingMethodAccessorImpl</code>），它所委派的具体实现便是一个本地实现（<code>NativeMethodAccessorImpl</code>）。本地实现非常容易理解。当进入了 Java 虚拟机内部之后，我们便拥有了 <code>Method</code> 实例所指向方法的具体地址。这时候，反射调用无非就是将传入的参数准备好，然后调用进入目标方法。</p>
<p>【示例】通过抛出异常方式 打印 <code>Method.invoke</code> 调用轨迹</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">target</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Exception(<span class="string">&quot;#&quot;</span> + i).printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;io.github.dunwu.javacore.reflect.MethodDemo01&quot;</span>);</span><br><span class="line">        Method method = clazz.getMethod(<span class="string">&quot;target&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        method.invoke(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// java.lang.Exception: #0</span></span><br><span class="line"><span class="comment">//     at io.github.dunwu.javacore.reflect.MethodDemo01.target(MethodDemo01.java:12)</span></span><br><span class="line"><span class="comment">//     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span></span><br><span class="line"><span class="comment">//     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span></span><br></pre></td></tr></table></figure>

<p>先调用 <code>DelegatingMethodAccessorImpl</code>；然后调用 <code>NativeMethodAccessorImpl</code>，最后调用实际方法。</p>
<p>为什么反射调用 <code>DelegatingMethodAccessorImpl</code> 作为中间层，而不是直接交给本地实现？</p>
<p>其实，Java 的反射调用机制还设立了另一种动态生成字节码的实现（下称动态实现），直接使用 invoke 指令来调用目标方法。之所以采用委派实现，便是为了能够在本地实现以及动态实现中切换。动态实现和本地实现相比，其运行效率要快上 20 倍。这是因为动态实现无需经过 Java 到 C++ 再到 Java 的切换，但由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上 3 到 4 倍。</p>
<p>考虑到许多反射调用仅会执行一次，Java 虚拟机设置了一个阈值 15（可以通过 <code>-Dsun.reflect.inflationThreshold</code> 来调整），当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 Inflation。</p>
<p>【示例】执行 java -verbose:class MethodDemo02 启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">target</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Exception(<span class="string">&quot;#&quot;</span> + i).printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; klass = Class.forName(<span class="string">&quot;io.github.dunwu.javacore.reflect.MethodDemo02&quot;</span>);</span><br><span class="line">        Method method = klass.getMethod(<span class="string">&quot;target&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            method.invoke(<span class="keyword">null</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...省略</span></span><br><span class="line">java.lang.Exception: #<span class="number">14</span></span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.target(MethodDemo02.java:<span class="number">13</span>)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.main(MethodDemo02.java:<span class="number">20</span>)</span><br><span class="line">[Loaded sun.reflect.ClassFileConstants from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.AccessorGenerator from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.MethodAccessorGenerator from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ByteVectorFactory from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ByteVector from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ByteVectorImpl from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ClassFileAssembler from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.UTF8 from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.Label from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.Label$PatchInfo from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.util.ArrayList$Itr from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.MethodAccessorGenerator$<span class="number">1</span> from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ClassDefiner from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.ClassDefiner$<span class="number">1</span> from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">[Loaded sun.reflect.GeneratedMethodAccessor1 from __JVM_DefineClass__]</span><br><span class="line">java.lang.Exception: #<span class="number">15</span></span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.target(MethodDemo02.java:<span class="number">13</span>)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.main(MethodDemo02.java:<span class="number">20</span>)</span><br><span class="line">[Loaded java.util.concurrent.ConcurrentHashMap$ForwardingNode from D:\Tools\Java\jdk1<span class="number">.8</span><span class="number">.0_192</span>\jre\lib\rt.jar]</span><br><span class="line">java.lang.Exception: #<span class="number">16</span></span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.target(MethodDemo02.java:<span class="number">13</span>)</span><br><span class="line">        at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">        at io.github.dunwu.javacore.reflect.MethodDemo02.main(MethodDemo02.java:<span class="number">20</span>)</span><br><span class="line"><span class="comment">// ...省略</span></span><br></pre></td></tr></table></figure>

<p>可以看到，从第 16 次开始后，都是使用 <code>DelegatingMethodAccessorImpl</code> ，不再使用本地实现 <code>NativeMethodAccessorImpl</code>。</p>
<h3 id="2-4-反射调用的开销"><a href="#2-4-反射调用的开销" class="headerlink" title="2.4. 反射调用的开销"></a>2.4. 反射调用的开销</h3><p>方法的反射调用会带来不少性能开销，原因主要有三个：</p>
<ul>
<li>变长参数方法导致的 Object 数组</li>
<li>基本类型的自动装箱、拆箱</li>
<li>还有最重要的方法内联</li>
</ul>
<p><code>Class.forName</code> 会调用本地方法，<code>Class.getMethod</code> 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。可想而知，这两个操作都非常费时。</p>
<blockquote>
<p>注意，以 <code>getMethod</code> 为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回 <code>Method</code> 数组的 <code>getMethods</code> 或者 <code>getDeclaredMethods</code> 方法，以减少不必要的堆空间消耗。在实践中，我们往往会在应用程序中缓存 <code>Class.forName</code> 和 <code>Class.getMethod</code> 的结果。</p>
</blockquote>
<p>下面只关注反射调用本身的性能开销。</p>
<p>第一，由于 Method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数会是 Object 数组（感兴趣的同学私下可以用 javap 查看）。Java 编译器会在方法调用处生成一个长度为传入参数数量的 Object 数组，并将传入参数一一存储进该数组中。</p>
<p>第二，由于 Object 数组不能存储基本类型，Java 编译器会对传入的基本类型参数进行自动装箱。</p>
<p>这两个操作除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。（如果你感兴趣的话，可以用虚拟机参数 -XX:+PrintGC 试试。）那么，如何消除这部分开销呢？</p>
<h2 id="3-使用反射"><a href="#3-使用反射" class="headerlink" title="3. 使用反射"></a>3. 使用反射</h2><h3 id="3-1-java-lang-reflect-包"><a href="#3-1-java-lang-reflect-包" class="headerlink" title="3.1. java.lang.reflect 包"></a>3.1. java.lang.reflect 包</h3><p>Java 中的 <code>java.lang.reflect</code> 包提供了反射功能。<code>java.lang.reflect</code> 包中的类都没有 <code>public</code> 构造方法。</p>
<p><code>java.lang.reflect</code> 包的核心接口和类如下：</p>
<ul>
<li><code>Member</code> 接口：反映关于单个成员(字段或方法)或构造函数的标识信息。</li>
<li><code>Field</code> 类：提供一个类的域的信息以及访问类的域的接口。</li>
<li><code>Method</code> 类：提供一个类的方法的信息以及访问类的方法的接口。</li>
<li><code>Constructor</code> 类：提供一个类的构造函数的信息以及访问类的构造函数的接口。</li>
<li><code>Array</code> 类：该类提供动态地生成和访问 JAVA 数组的方法。</li>
<li><code>Modifier</code> 类：提供了 static 方法和常量，对类和成员访问修饰符进行解码。</li>
<li><code>Proxy</code> 类：提供动态地生成代理类和类实例的静态方法。</li>
</ul>
<h3 id="3-2-获取-Class-对象"><a href="#3-2-获取-Class-对象" class="headerlink" title="3.2. 获取 Class 对象"></a>3.2. 获取 Class 对象</h3><p>获取 <code>Class</code> 对象的三种方法：</p>
<p>（1）**<code>Class.forName</code> 静态方法**</p>
<p>【示例】使用 <code>Class.forName</code> 静态方法获取 <code>Class</code> 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.dunwu.javacore.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectClassDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class c1 = Class.forName(<span class="string">&quot;io.github.dunwu.javacore.reflect.ReflectClassDemo01&quot;</span>);</span><br><span class="line">        System.out.println(c1.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        Class c2 = Class.forName(<span class="string">&quot;[D&quot;</span>);</span><br><span class="line">        System.out.println(c2.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        Class c3 = Class.forName(<span class="string">&quot;[[Ljava.lang.String;&quot;</span>);</span><br><span class="line">        System.out.println(c3.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//io.github.dunwu.javacore.reflect.ReflectClassDemo01</span></span><br><span class="line"><span class="comment">//double[]</span></span><br><span class="line"><span class="comment">//java.lang.String[][]</span></span><br></pre></td></tr></table></figure>

<p>使用类的完全限定名来反射对象的类。常见的应用场景为：在 JDBC 开发中常用此方法加载数据库驱动。</p>
<p>（2）<strong>类名 + <code>.class</code></strong></p>
<p>【示例】直接用类名 + <code>.class</code> 获取 <code>Class</code> 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectClassDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b;</span><br><span class="line">        <span class="comment">// Class c = b.getClass(); // 编译错误</span></span><br><span class="line">        Class c1 = <span class="keyword">boolean</span>.class;</span><br><span class="line">        System.out.println(c1.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        Class c2 = java.io.PrintStream.class;</span><br><span class="line">        System.out.println(c2.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        Class c3 = <span class="keyword">int</span>[][][].class;</span><br><span class="line">        System.out.println(c3.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//boolean</span></span><br><span class="line"><span class="comment">//java.io.PrintStream</span></span><br><span class="line"><span class="comment">//int[][][]</span></span><br></pre></td></tr></table></figure>

<p>（3）**<code>Object</code> 的 <code>getClass</code> 方法**</p>
<p><code>Object</code> 类中有 <code>getClass</code> 方法，因为所有类都继承 <code>Object</code> 类。从而调用 <code>Object</code> 类来获取 <code>Class</code> 对象。</p>
<p>【示例】<code>Object</code> 的 <code>getClass</code> 方法获取 <code>Class</code> 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.dunwu.javacore.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectClassDemo03</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">E</span> </span>&#123;A, B&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c = <span class="string">&quot;foo&quot;</span>.getClass();</span><br><span class="line">        System.out.println(c.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        Class c2 = ReflectClassDemo03.E.A.getClass();</span><br><span class="line">        System.out.println(c2.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        Class c3 = bytes.getClass();</span><br><span class="line">        System.out.println(c3.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Class c4 = set.getClass();</span><br><span class="line">        System.out.println(c4.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//java.lang.String</span></span><br><span class="line"><span class="comment">//io.github.dunwu.javacore.reflect.ReflectClassDemo.E</span></span><br><span class="line"><span class="comment">//byte[]</span></span><br><span class="line"><span class="comment">//java.util.HashSet</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-判断是否为某个类的实例"><a href="#3-3-判断是否为某个类的实例" class="headerlink" title="3.3. 判断是否为某个类的实例"></a>3.3. 判断是否为某个类的实例</h3><p>判断是否为某个类的实例有两种方式：</p>
<ol>
<li><strong>用 <code>instanceof</code> 关键字</strong></li>
<li><strong>用 <code>Class</code> 对象的 <code>isInstance</code> 方法</strong>（它是一个 Native 方法）</li>
</ol>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceofDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">if</span> (arrayList <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ArrayList is List&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (List.class.isInstance(arrayList)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ArrayList is List&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//ArrayList is List</span></span><br><span class="line"><span class="comment">//ArrayList is List</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-创建实例"><a href="#3-4-创建实例" class="headerlink" title="3.4. 创建实例"></a>3.4. 创建实例</h3><p>通过反射来创建实例对象主要有两种方式：</p>
<ul>
<li>用 <code>Class</code> 对象的 <code>newInstance</code> 方法。</li>
<li>用 <code>Constructor</code> 对象的 <code>newInstance</code> 方法。</li>
</ul>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; c1 = StringBuilder.class;</span><br><span class="line">        StringBuilder sb = (StringBuilder) c1.newInstance();</span><br><span class="line">        sb.append(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">        Class&lt;?&gt; c2 = String.class;</span><br><span class="line">        <span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">        Constructor constructor = c2.getConstructor(String.class);</span><br><span class="line">        <span class="comment">//根据构造器创建实例</span></span><br><span class="line">        String str2 = (String) constructor.newInstance(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//aaa</span></span><br><span class="line"><span class="comment">//bbb</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-创建数组实例"><a href="#3-5-创建数组实例" class="headerlink" title="3.5. 创建数组实例"></a>3.5. 创建数组实例</h3><p>数组在 Java 里是比较特殊的一种类型，它可以赋值给一个对象引用。Java 中，<strong>通过 <code>Array.newInstance</code> 创建数组的实例</strong>。</p>
<p>【示例】利用反射创建数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        Object array = Array.newInstance(cls, <span class="number">25</span>);</span><br><span class="line">        <span class="comment">//往数组里添加内容</span></span><br><span class="line">        Array.set(array, <span class="number">0</span>, <span class="string">&quot;Scala&quot;</span>);</span><br><span class="line">        Array.set(array, <span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        Array.set(array, <span class="number">2</span>, <span class="string">&quot;Groovy&quot;</span>);</span><br><span class="line">        Array.set(array, <span class="number">3</span>, <span class="string">&quot;Scala&quot;</span>);</span><br><span class="line">        Array.set(array, <span class="number">4</span>, <span class="string">&quot;Clojure&quot;</span>);</span><br><span class="line">        <span class="comment">//获取某一项的内容</span></span><br><span class="line">        System.out.println(Array.get(array, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//Scala</span></span><br></pre></td></tr></table></figure>

<p>其中的 Array 类为 <code>java.lang.reflect.Array</code> 类。我们 <code>Array.newInstance</code> 的原型是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NegativeArraySizeException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> newArray(componentType, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-Field"><a href="#3-6-Field" class="headerlink" title="3.6. Field"></a>3.6. Field</h3><p><code>Class</code> 对象提供以下方法获取对象的成员（<code>Field</code>）：</p>
<ul>
<li><code>getFiled</code> - 根据名称获取公有的（public）类成员。</li>
<li><code>getDeclaredField</code> - 根据名称获取已声明的类成员。但不能得到其父类的类成员。</li>
<li><code>getFields</code> - 获取所有公有的（public）类成员。</li>
<li><code>getDeclaredFields</code> - 获取所有已声明的类成员。</li>
</ul>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectFieldDemo</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FieldSpy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span>[][] b = &#123; &#123;<span class="keyword">false</span>, <span class="keyword">false</span>&#125;, &#123;<span class="keyword">true</span>, <span class="keyword">true</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">public</span> String name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> List&lt;Integer&gt; list;</span><br><span class="line">        <span class="keyword">public</span> T val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</span><br><span class="line">        Field f1 = FieldSpy.class.getField(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        System.out.format(<span class="string">&quot;Type: %s%n&quot;</span>, f1.getType());</span><br><span class="line"></span><br><span class="line">        Field f2 = FieldSpy.class.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.format(<span class="string">&quot;Type: %s%n&quot;</span>, f2.getType());</span><br><span class="line"></span><br><span class="line">        Field f3 = FieldSpy.class.getField(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">        System.out.format(<span class="string">&quot;Type: %s%n&quot;</span>, f3.getType());</span><br><span class="line"></span><br><span class="line">        Field f4 = FieldSpy.class.getField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        System.out.format(<span class="string">&quot;Type: %s%n&quot;</span>, f4.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//Type: class [[Z</span></span><br><span class="line"><span class="comment">//Type: class java.lang.String</span></span><br><span class="line"><span class="comment">//Type: interface java.util.List</span></span><br><span class="line"><span class="comment">//Type: class java.lang.Object</span></span><br></pre></td></tr></table></figure>

<h3 id="3-7-Method"><a href="#3-7-Method" class="headerlink" title="3.7. Method"></a>3.7. Method</h3><p><code>Class</code> 对象提供以下方法获取对象的方法（<code>Method</code>）：</p>
<ul>
<li><code>getMethod</code> - 返回类或接口的特定方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li>
<li><code>getDeclaredMethod</code> - 返回类或接口的特定声明方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。</li>
<li><code>getMethods</code> - 返回类或接口的所有 public 方法，包括其父类的 public 方法。</li>
<li><code>getDeclaredMethods</code> - 返回类或接口声明的所有方法，包括 public、protected、默认（包）访问和 private 方法，但不包括继承的方法。</li>
</ul>
<p>获取一个 <code>Method</code> 对象后，可以用 <code>invoke</code> 方法来调用这个方法。</p>
<p><code>invoke</code> 方法的原型为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">           InvocationTargetException</span></span><br></pre></td></tr></table></figure>

<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回所有方法</span></span><br><span class="line">        Method[] methods1 = System.class.getDeclaredMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;System getDeclaredMethods 清单（数量 = &quot;</span> + methods1.length + <span class="string">&quot;）：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods1) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回所有 public 方法</span></span><br><span class="line">        Method[] methods2 = System.class.getMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;System getMethods 清单（数量 = &quot;</span> + methods2.length + <span class="string">&quot;）：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods2) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用 Method 的 invoke 方法调用 System.currentTimeMillis()</span></span><br><span class="line">        Method method = System.class.getMethod(<span class="string">&quot;currentTimeMillis&quot;</span>);</span><br><span class="line">        System.out.println(method);</span><br><span class="line">        System.out.println(method.invoke(<span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-8-Constructor"><a href="#3-8-Constructor" class="headerlink" title="3.8. Constructor"></a>3.8. Constructor</h3><p><code>Class</code> 对象提供以下方法获取对象的构造方法（<code>Constructor</code>）：</p>
<ul>
<li><code>getConstructor</code> - 返回类的特定 public 构造方法。参数为方法参数对应 Class 的对象。</li>
<li><code>getDeclaredConstructor</code> - 返回类的特定构造方法。参数为方法参数对应 Class 的对象。</li>
<li><code>getConstructors</code> - 返回类的所有 public 构造方法。</li>
<li><code>getDeclaredConstructors</code> - 返回类的所有构造方法。</li>
</ul>
<p>获取一个 <code>Constructor</code> 对象后，可以用 <code>newInstance</code> 方法来创建类实例。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectMethodConstructorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        Constructor&lt;?&gt;[] constructors1 = String.class.getDeclaredConstructors();</span><br><span class="line">        System.out.println(<span class="string">&quot;String getDeclaredConstructors 清单（数量 = &quot;</span> + constructors1.length + <span class="string">&quot;）：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors1) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt;[] constructors2 = String.class.getConstructors();</span><br><span class="line">        System.out.println(<span class="string">&quot;String getConstructors 清单（数量 = &quot;</span> + constructors2.length + <span class="string">&quot;）：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors2) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        Constructor constructor = String.class.getConstructor(String.class);</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">        String str = (String) constructor.newInstance(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-9-绕开访问限制"><a href="#3-9-绕开访问限制" class="headerlink" title="3.9. 绕开访问限制"></a>3.9. 绕开访问限制</h3><p>有时候，我们需要通过反射访问私有成员、方法。可以使用 <code>Constructor/Field/Method.setAccessible(true)</code> 来绕开 Java 语言的访问限制。</p>
<h2 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4. 动态代理"></a>4. 动态代理</h2><p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p>
<p>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/Java%E4%BB%A3%E7%90%86.svg" alt="img"></p>
<h3 id="4-1-静态代理"><a href="#4-1-静态代理" class="headerlink" title="4.1. 静态代理"></a>4.1. 静态代理</h3><blockquote>
<p>静态代理其实就是指设计模式中的代理模式。</p>
<p><strong>代理模式为其他对象提供一种代理以控制对这个对象的访问。</strong></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/3101171-6269723ea61527bd.png" alt="img"></p>
<p><strong>Subject</strong> 定义了 RealSubject 和 Proxy 的公共接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RealSubject</strong> 定义 Proxy 所代表的真实实体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;真实的请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Proxy</strong> 保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject real;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == real) &#123;</span><br><span class="line">            real = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        real.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<p>静态代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于 Proxy 和 RealSubject 的功能本质上是相同的，Proxy 只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。</p>
</blockquote>
<h3 id="4-2-JDK-动态代理"><a href="#4-2-JDK-动态代理" class="headerlink" title="4.2. JDK 动态代理"></a>4.2. JDK 动态代理</h3><p>为了解决静态代理的问题，就有了创建动态代理的想法：</p>
<p>在运行状态中，需要代理的地方，根据 Subject 和 RealSubject，动态地创建一个 Proxy，用完之后，就会销毁，这样就可以避免了 Proxy 角色的 class 在系统中冗杂的问题了。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1553614585028.png" alt="img"></p>
<p>Java 动态代理基于经典代理模式，引入了一个 <code>InvocationHandler</code>，<code>InvocationHandler</code> 负责统一管理所有的方法调用。</p>
<p>动态代理步骤：</p>
<ol>
<li>获取 RealSubject 上的所有接口列表；</li>
<li>确定要生成的代理类的类名，默认为：<code>com.sun.proxy.$ProxyXXXX</code>；</li>
<li>根据需要实现的接口信息，在代码中动态创建 该 Proxy 类的字节码；</li>
<li>将对应的字节码转换为对应的 class 对象；</li>
<li>创建 <code>InvocationHandler</code> 实例 handler，用来处理 <code>Proxy</code> 所有方法调用；</li>
<li>Proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。</li>
</ol>
<p>从上面可以看出，JDK 动态代理的实现是基于实现接口的方式，使得 Proxy 和 RealSubject 具有相同的功能。</p>
<p>但其实还有一种思路：通过继承。即：让 Proxy 继承 RealSubject，这样二者同样具有相同的功能，Proxy 还可以通过重写 RealSubject 中的方法，来实现多态。CGLIB 就是基于这种思路设计的。</p>
<p>在 Java 的动态代理机制中，有两个重要的类（接口），一个是 <code>InvocationHandler</code> 接口、另一个则是 <code>Proxy</code> 类，这一个类和一个接口是实现我们动态代理所必须用到的。</p>
<h4 id="InvocationHandler-接口"><a href="#InvocationHandler-接口" class="headerlink" title="InvocationHandler 接口"></a>InvocationHandler 接口</h4><p><code>InvocationHandler</code> 接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个动态代理类都必须要实现 <code>InvocationHandler</code> 这个接口，并且每个代理类的实例都关联到了一个 Handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 <code>InvocationHandler</code> 这个接口的 <code>invoke</code> 方法来进行调用。</p>
<p>我们来看看 InvocationHandler 这个接口的唯一一个方法 invoke 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><strong>proxy</strong> - 代理的真实对象。</li>
<li><strong>method</strong> - 所要调用真实对象的某个方法的 <code>Method</code> 对象</li>
<li><strong>args</strong> - 所要调用真实对象某个方法时接受的参数</li>
</ul>
<p>如果不是很明白，等下通过一个实例会对这几个参数进行更深的讲解。</p>
<h4 id="Proxy-类"><a href="#Proxy-类" class="headerlink" title="Proxy 类"></a>Proxy 类</h4><p><code>Proxy</code> 这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 <code>newProxyInstance</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)</span>  <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>

<p>这个方法的作用就是得到一个动态的代理对象。</p>
<p>参数说明：</p>
<ul>
<li><strong>loader</strong> - 一个 <code>ClassLoader</code> 对象，定义了由哪个 <code>ClassLoader</code> 对象来对生成的代理对象进行加载。</li>
<li><strong>interfaces</strong> - 一个 <code>Class&lt;?&gt;</code> 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了</li>
<li><strong>h</strong> - 一个 <code>InvocationHandler</code> 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 <code>InvocationHandler</code> 对象上</li>
</ul>
<h4 id="JDK-动态代理实例"><a href="#JDK-动态代理实例" class="headerlink" title="JDK 动态代理实例"></a>JDK 动态代理实例</h4><p>上面的内容介绍完这两个接口(类)以后，我们来通过一个实例来看看我们的动态代理模式是什么样的：</p>
<p>首先我们定义了一个 Subject 类型的接口，为其声明了两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">bye</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，定义了一个类来实现这个接口，这个类就是我们的真实对象，RealSubject 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello  &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Goodbye&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Over&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步，我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerDemo</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个就是我们要代理的真实对象</span></span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，给我们要代理的真实对象赋初值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationHandlerDemo</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object object, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 在代理真实对象前我们可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before method&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Call Method: &quot;</span> + method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span><br><span class="line">        Object obj = method.invoke(subject, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在代理真实对象后我们也可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，来看看我们的 Client 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 我们要代理的真实对象</span></span><br><span class="line">        Subject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerDemo(realSubject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数</span></span><br><span class="line"><span class="comment">         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象</span></span><br><span class="line"><span class="comment">         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了</span></span><br><span class="line"><span class="comment">         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject</span><br><span class="line">                .getClass().getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line">        System.out.println(subject.getClass().getName());</span><br><span class="line">        subject.hello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        String result = subject.bye();</span><br><span class="line">        System.out.println(<span class="string">&quot;Result is: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来看看控制台的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.sun.proxy.$Proxy0</span><br><span class="line">Before method</span><br><span class="line">Call Method: public abstract void io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.hello(java.lang.String)</span><br><span class="line">Hello  World</span><br><span class="line">After method</span><br><span class="line"></span><br><span class="line">Before method</span><br><span class="line">Call Method: public abstract java.lang.String io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.bye()</span><br><span class="line">Goodbye</span><br><span class="line">After method</span><br><span class="line"></span><br><span class="line">Result is: Over</span><br></pre></td></tr></table></figure>

<p>我们首先来看看 <code>com.sun.proxy.$Proxy0</code> 这东西，我们看到，这个东西是由 <code>System.out.println(subject.getClass().getName());</code> 这条语句打印出来的，那么为什么我们返回的这个代理对象的类名是这样的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject</span><br><span class="line">                .getClass().getInterfaces(), handler);</span><br></pre></td></tr></table></figure>

<p>可能我以为返回的这个代理对象会是 Subject 类型的对象，或者是 InvocationHandler 的对象，结果却不是，首先我们解释一下<strong>为什么我们这里可以将其转化为 Subject 类型的对象？</strong></p>
<p>原因就是：在 newProxyInstance 这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是 Subject 类型，所以就可以将其转化为 Subject 类型了。</p>
<p><strong>同时我们一定要记住，通过 <code>Proxy.newProxyInstance</code> 创建的代理对象是在 jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy 为中，最后一个数字表示对象的标号</strong>。</p>
<p>接着我们来看看这两句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subject.hello(&quot;World&quot;);</span><br><span class="line">String result = subject.bye();</span><br></pre></td></tr></table></figure>

<p>这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的 invoke 方法去执行，而我们的这个 handler 对象又接受了一个 RealSubject 类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的 invoke 方法去执行。</p>
<p>我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.hello(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> java.lang.String io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.bye()</span><br></pre></td></tr></table></figure>

<p>正好就是我们的 Subject 接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的 invoke 方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。</p>
<h4 id="JDK-动态代理小结"><a href="#JDK-动态代理小结" class="headerlink" title="JDK 动态代理小结"></a>JDK 动态代理小结</h4><p>代理类与委托类实现同一接口，主要是通过代理类实现 <code>InvocationHandler</code> 并重写 <code>invoke</code> 方法来进行动态代理的，在 <code>invoke</code> 方法中将对方法进行处理。</p>
<p>JDK 动态代理特点：</p>
<ul>
<li>优点：相对于静态代理模式，不需要硬编码接口，代码复用率高。</li>
<li>缺点：强制要求代理类实现 <code>InvocationHandler</code> 接口。</li>
</ul>
<h3 id="4-3-CGLIB-动态代理"><a href="#4-3-CGLIB-动态代理" class="headerlink" title="4.3. CGLIB 动态代理"></a>4.3. CGLIB 动态代理</h3><p>CGLIB 提供了与 JDK 动态代理不同的方案。很多框架，例如 Spring AOP 中，就使用了 CGLIB 动态代理。</p>
<p>CGLIB 底层，其实是借助了 ASM 这个强大的 Java 字节码框架去进行字节码增强操作。</p>
<p>CGLIB 动态代理的工作步骤：</p>
<ul>
<li>生成代理类的二进制字节码文件；</li>
<li>加载二进制字节码，生成 <code>Class</code> 对象( 例如使用 <code>Class.forName()</code> 方法 )；</li>
<li>通过反射机制获得实例构造，并创建代理类对象。</li>
</ul>
<p>CGLIB 动态代理特点：</p>
<p>优点：使用字节码增强，比 JDK 动态代理方式性能高。可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口。</p>
<p>缺点：不能对 <code>final</code> 类以及 <code>final</code> 方法进行代理。</p>
<blockquote>
<p>参考：<a href="https://www.jianshu.com/p/9a61af393e41">深入理解 CGLIB 动态代理机制</a></p>
</blockquote>
<h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
<li><a href="https://time.geekbang.org/column/intro/100010301">深入拆解 Java 虚拟机</a></li>
<li><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析 Java 反射（1） - 基础</a></li>
<li><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078">Java 基础之—反射（非常重要）</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html">官方 Reflection API 文档</a></li>
<li><a href="https://www.cnblogs.com/xiaoluo501395377/p/3383130.html">Java 的动态代理机制详解</a></li>
<li><a href="https://blog.csdn.net/luanlouis/article/details/24589193">Java 动态代理机制详解（JDK 和 CGLIB，Javassist，ASM）</a></li>
<li><a href="https://www.jianshu.com/p/471c80a7e831">深入理解 JDK 动态代理机制</a></li>
<li><a href="https://www.jianshu.com/p/9a61af393e41">深入理解 CGLIB 动态代理机制</a></li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java 方法</title>
    <url>/2021/12/06/java-method/</url>
    <content><![CDATA[<h1 id="深入理解-Java-方法"><a href="#深入理解-Java-方法" class="headerlink" title="深入理解 Java 方法"></a>深入理解 Java 方法</h1><blockquote>
<p><strong>方法（有的人喜欢叫函数）是一段可重用的代码段。</strong></p>
<p><strong>📦 本文以及示例源码已归档在 <a href="https://github.com/dunwu/javacore/">javacore</a></strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->

<ul>
<li><a href="#1-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8">1. 方法的使用</a><ul>
<li><a href="#11-%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89">1.1. 方法定义</a></li>
<li><a href="#12-%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8">1.2. 方法的调用</a></li>
</ul>
</li>
<li><a href="#2-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0">2. 方法参数</a></li>
<li><a href="#3-%E6%96%B9%E6%B3%95%E4%BF%AE%E9%A5%B0%E7%AC%A6">3. 方法修饰符</a><ul>
<li><a href="#31-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6">3.1. 访问控制修饰符</a></li>
<li><a href="#32-static">3.2. static</a></li>
<li><a href="#33-final">3.3. final</a></li>
<li><a href="#34-default">3.4. default</a></li>
<li><a href="#35-abstract">3.5. abstract</a></li>
<li><a href="#36-synchronized">3.6. synchronized</a></li>
</ul>
</li>
<li><a href="#4-%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95">4. 特殊方法</a><ul>
<li><a href="#41-main-%E6%96%B9%E6%B3%95">4.1. main 方法</a></li>
<li><a href="#42-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">4.2. 构造方法</a></li>
<li><a href="#43-%E5%8F%98%E5%8F%82%E6%96%B9%E6%B3%95">4.3. 变参方法</a></li>
<li><a href="#44-finalize-%E6%96%B9%E6%B3%95">4.4. finalize() 方法</a></li>
</ul>
</li>
<li><a href="#5-%E8%A6%86%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD">5. 覆写和重载</a></li>
<li><a href="#6-%E5%B0%8F%E7%BB%93">6. 小结</a></li>
<li><a href="#7-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">7. 参考资料</a></li>
</ul>
<!-- /TOC -->

<h2 id="1-方法的使用"><a href="#1-方法的使用" class="headerlink" title="1. 方法的使用"></a>1. 方法的使用</h2><h3 id="1-1-方法定义"><a href="#1-1-方法定义" class="headerlink" title="1.1. 方法定义"></a>1.1. 方法定义</h3><p>方法定义语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[修饰符] 返回值类型 方法名([参数类型 参数名])&#123;</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li><strong>修饰符</strong> - 修饰符是可选的，它告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li><strong>返回值类型</strong> - 返回值类型表示方法执行结束后，返回结果的数据类型。如果没有返回值，应设为 void。</li>
<li><strong>方法名</strong> - 是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li><strong>参数类型</strong> - 参数像是一个占位符。当方法被调用时，传递值给参数。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li>
<li><strong>方法体</strong> - 方法体包含具体的语句，定义该方法的功能。</li>
<li><strong>return</strong> - 必须返回声明方法时返回值类型相同的数据类型。在 void 方法中，return 语句可有可无，如果要写 return，则只能是 <code>return;</code> 这种形式。</li>
</ul>
<h3 id="1-2-方法的调用"><a href="#1-2-方法的调用" class="headerlink" title="1.2. 方法的调用"></a>1.2. 方法的调用</h3><p>当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。</p>
<p>Java 支持两种调用方法的方式，根据方法是否有返回值来选择。</p>
<ul>
<li>有返回值方法 - 有返回值方法通常被用来给一个变量赋值或代入到运算表达式中进行计算。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int larger = max(30, 40);</span><br></pre></td></tr></table></figure>

<ul>
<li>无返回值方法 - 无返回值方法只能是一条语句。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(&quot;Hello World&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h4><p>Java 支持方法的递归调用（即方法调用自身）。</p>
<blockquote>
<p>🔔 注意：</p>
<ul>
<li>递归方法必须有明确的结束条件。</li>
<li>尽量避免使用递归调用。因为递归调用如果处理不当，可能导致栈溢出。</li>
</ul>
</blockquote>
<p>斐波那契数列（一个典型的递归算法）示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span> || num == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fib(num - <span class="number">2</span>) + fib(num - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(fib(i) + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-方法参数"><a href="#2-方法参数" class="headerlink" title="2. 方法参数"></a>2. 方法参数</h2><p>在 C/C++ 等编程语言中，方法的参数传递一般有两种形式：</p>
<ul>
<li>值传递 - 值传递的参数被称为形参。值传递时，传入的参数，在方法中的修改，不会在方法外部生效。</li>
<li>引用传递 - 引用传递的参数被称为实参。引用传递时，传入的参数，在方法中的修改，会在方法外部生效。</li>
</ul>
<p>那么，Java 中是怎样的呢？</p>
<p><strong>Java 中只有值传递。</strong></p>
<p>示例一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodParamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        value =  value + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        method(num);</span><br><span class="line">        System.out.println(<span class="string">&quot;num = [&quot;</span> + num + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        method(num);</span><br><span class="line">        System.out.println(<span class="string">&quot;num = [&quot;</span> + num + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// num = [0]</span></span><br><span class="line"><span class="comment">// num = [0]</span></span><br></pre></td></tr></table></figure>

<p>示例二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodParamDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb = [&quot;</span> + sb.toString() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        method(sb);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb = [&quot;</span> + sb.toString() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb = [&quot;</span> + sb.toString() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// sb = [A]</span></span><br><span class="line"><span class="comment">// sb = [A]</span></span><br><span class="line"><span class="comment">// sb = [C]</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>以上两个示例，无论向方法中传入的是基础数据类型，还是引用类型，在方法中修改的值，在外部都未生效。</p>
<p>Java 对于基本数据类型，会直接拷贝值传递到方法中；对于引用数据类型，拷贝当前对象的引用地址，然后把该地址传递过去，所以也是值传递。</p>
<blockquote>
<p>扩展阅读：</p>
<p><a href="https://zhuanlan.zhihu.com/p/24556934?refer=dreawer">图解 Java 中的参数传递</a></p>
</blockquote>
<h2 id="3-方法修饰符"><a href="#3-方法修饰符" class="headerlink" title="3. 方法修饰符"></a>3. 方法修饰符</h2><p>前面提到了，Java 方法的修饰符是可选的，它告诉编译器如何调用该方法。定义了该方法的访问类型。</p>
<p>Java 方法有好几个修饰符，让我们一一来认识一下：</p>
<h3 id="3-1-访问控制修饰符"><a href="#3-1-访问控制修饰符" class="headerlink" title="3.1. 访问控制修饰符"></a>3.1. 访问控制修饰符</h3><p>访问权限控制的等级，从最大权限到最小权限依次为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public &gt; protected &gt; 包访问权限（没有任何关键字）&gt; private</span><br></pre></td></tr></table></figure>

<ul>
<li><code>public</code> - 表示任何类都可以访问；</li>
<li><code>包访问权限</code> - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。</li>
<li><code>protected</code> - 表示子类可以访问，此外，同一个包内的其他类也可以访问，即使这些类不是子类。</li>
<li><code>private</code> - 表示其它任何类都无法访问。</li>
</ul>
<h3 id="3-2-static"><a href="#3-2-static" class="headerlink" title="3.2. static"></a>3.2. static</h3><p><strong>被 <code>static</code> 修饰的方法被称为静态方法。</strong></p>
<p>静态方法相比于普通的实例方法，主要有以下区别：</p>
<ul>
<li>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象名.方法名</code> 的方式。而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。</li>
<li><strong>静态方法在访问本类的成员时，只允许访问静态成员</strong>（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li>
</ul>
<p>静态方法常被用于各种工具类、工厂方法类。</p>
<h3 id="3-3-final"><a href="#3-3-final" class="headerlink" title="3.3. final"></a>3.3. final</h3><p>被 <code>final</code> 修饰的方法不能被子类覆写（Override）。</p>
<p>final 方法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;call Father print()&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;call print()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father demo = <span class="keyword">new</span> Son();</span><br><span class="line">        demo.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译时会报错</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<p>上面示例中，父类 Father 中定义了一个 <code>final</code> 方法 <code>print()</code>，则其子类不能 Override 这个 final 方法，否则会编译报错。</p>
</blockquote>
<h3 id="3-4-default"><a href="#3-4-default" class="headerlink" title="3.4. default"></a>3.4. default</h3><p>JDK8 开始，支持在接口 <code>Interface</code> 中定义 <code>default</code> 方法。**<code>default</code> 方法只能出现在接口 <code>Interface</code> 中**。</p>
<p><strong>接口中被 <code>default</code> 修饰的方法被称为默认方法，实现此接口的类如果没 Override 此方法，则直接继承这个方法，不再强制必须实现此方法。</strong></p>
<p>default 方法语法的出现，是为了既有的成千上万的 Java 类库的类增加新的功能， 且不必对这些类重新进行设计。 举例来说，JDK8 中 <code>Collection</code> 类中有一个非常方便的 <code>stream()</code> 方法，就是被修饰为 <code>default</code>，Collection 的一大堆 List、Set 子类就直接继承了这个方法 I，不必再为每个子类都注意添加这个方法。</p>
<p><code>default</code> 方法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyInterface obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">        obj.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-abstract"><a href="#3-5-abstract" class="headerlink" title="3.5. abstract"></a>3.5. abstract</h3><p><strong>被 <code>abstract</code> 修饰的方法被称为抽象方法，方法不能有实体。抽象方法只能出现抽象类中。</strong></p>
<p>抽象方法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;call print()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass demo = <span class="keyword">new</span> ConcreteClass();</span><br><span class="line">        demo.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Outpu:</span></span><br><span class="line"><span class="comment">// call print()</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-synchronized"><a href="#3-6-synchronized" class="headerlink" title="3.6. synchronized"></a>3.6. synchronized</h3><p><code>synchronized</code> 用于并发编程。<strong>被 <code>synchronized</code> 修饰的方法在一个时刻，只允许一个线程执行。</strong></p>
<p>在 Java 的同步容器（Vector、Stack、HashTable）中，你会见到大量的 synchronized 方法。不过，请记住：在 Java 并发编程中，synchronized 方法并不是一个好的选择，大多数情况下，我们会选择更加轻量级的锁 。</p>
<h2 id="4-特殊方法"><a href="#4-特殊方法" class="headerlink" title="4. 特殊方法"></a>4. 特殊方法</h2><p>Java 中，有一些较为特殊的方法，分别使用于特殊的场景。</p>
<h3 id="4-1-main-方法"><a href="#4-1-main-方法" class="headerlink" title="4.1. main 方法"></a>4.1. main 方法</h3><p>Java 中的 main 方法是一种特殊的静态方法，因为所有的 Java 程序都是由 <code>public static void main(String[] args)</code> 方法开始执行。</p>
<p>有很多新手虽然一直用 main 方法，却不知道 main 方法中的 args 有什么用。实际上，这是用来接收接收命令行输入参数的。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;arg = [&quot;</span> + arg + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依次执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac MainMethodDemo.java</span><br><span class="line">java MainMethodDemo A B C</span><br></pre></td></tr></table></figure>

<p>控制台会打印输出参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arg = [A]</span><br><span class="line">arg = [B]</span><br><span class="line">arg = [C]</span><br></pre></td></tr></table></figure>

<h3 id="4-2-构造方法"><a href="#4-2-构造方法" class="headerlink" title="4.2. 构造方法"></a>4.2. 构造方法</h3><p>任何类都有构造方法，构造方法的作用就是在初始化类实例时，设置实例的状态。</p>
<p>每个类都有构造方法。如果没有显式地为类定义任何构造方法，Java 编译器将会为该类提供一个默认构造方法。</p>
<p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorMethodDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;person name is &quot;</span> + person.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，构造方法除了使用 public，也可以使用 private 修饰，这种情况下，类无法调用此构造方法去实例化对象，这常常用于设计模式中的单例模式。</p>
<h3 id="4-3-变参方法"><a href="#4-3-变参方法" class="headerlink" title="4.3. 变参方法"></a>4.3. 变参方法</h3><p>JDK5 开始，Java 支持传递同类型的可变参数给一个方法。在方法声明中，在指定参数类型后加一个省略号 <code>...</code>。一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p>
<p>变参方法示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class VarargsDemo &#123;</span><br><span class="line">    public static void method(String... params) &#123;</span><br><span class="line">        System.out.println(&quot;params.length = &quot; + params.length);</span><br><span class="line">        for (String param : params) &#123;</span><br><span class="line">            System.out.println(&quot;params = [&quot; + param + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        method(&quot;red&quot;);</span><br><span class="line">        method(&quot;red&quot;, &quot;yellow&quot;);</span><br><span class="line">        method(&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Output:</span><br><span class="line">// params.length = 1</span><br><span class="line">// params = [red]</span><br><span class="line">// params.length = 2</span><br><span class="line">// params = [red]</span><br><span class="line">// params = [yellow]</span><br><span class="line">// params.length = 3</span><br><span class="line">// params = [red]</span><br><span class="line">// params = [yellow]</span><br><span class="line">// params = [blue]</span><br></pre></td></tr></table></figure>

<h3 id="4-4-finalize-方法"><a href="#4-4-finalize-方法" class="headerlink" title="4.4. finalize() 方法"></a>4.4. finalize() 方法</h3><p><code>finalize</code> 在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。</p>
<p><code>finalize</code> 是在 <code>java.lang.Object</code> 里定义的，也就是说每一个对象都有这么个方法。这个方法在 GC 启动，该对象被回收的时候被调用。</p>
<p>finalizer() 通常是不可预测的，也是很危险的，一般情况下是不必要的。使用终结方法会导致行为不稳定、降低性能，以及可移植性问题。</p>
<p><strong>请记住：应该尽量避免使用 <code>finalizer()</code><strong>。千万不要把它当成是 C/C++ 中的析构函数来用。原因是：</strong>Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的 CPU 时间较少，因此它永远也赶不上主线程的步伐。所以最后可能会发生 OutOfMemoryError 异常。</strong></p>
<blockquote>
<p>扩展阅读：</p>
<p>下面两篇文章比较详细的讲述了 finalizer() 可能会造成的问题及原因。</p>
<ul>
<li><a href="http://www.cnblogs.com/benwu/articles/5812903.html">Java 的 Finalizer 引发的内存溢出</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27850176">重载 Finalize 引发的内存泄露</a></li>
</ul>
</blockquote>
<h2 id="5-覆写和重载"><a href="#5-覆写和重载" class="headerlink" title="5. 覆写和重载"></a>5. 覆写和重载</h2><p><strong>覆写（Override）是指子类定义了与父类中同名的方法，但是在方法覆写时必须考虑到访问权限，子类覆写的方法不能拥有比父类更加严格的访问权限。</strong></p>
<p>子类要覆写的方法如果要访问父类的方法，可以使用 <code>super</code> 关键字。</p>
<p>覆写示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodOverrideDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;会动&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.move();</span><br><span class="line">            System.out.println(<span class="string">&quot;会跑&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 会动</span></span><br><span class="line"><span class="comment">// 会跑</span></span><br></pre></td></tr></table></figure>

<p><strong>方法的重载（Overload）是指方法名称相同，但参数的类型或参数的个数不同。通过传递参数的个数及类型的不同可以完成不同功能的方法调用。</strong></p>
<blockquote>
<p>🔔 注意：</p>
<p>重载一定是方法的参数不完全相同。如果方法的参数完全相同，仅仅是返回值不同，Java 是无法编译通过的。</p>
</blockquote>
<p>重载示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodOverloadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;x + y = &quot;</span> + (x + y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;x + y = &quot;</span> + (x + y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        add(<span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// x + y = 30</span></span><br><span class="line"><span class="comment">// x + y = 3.0</span></span><br></pre></td></tr></table></figure>

<h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1553767582595.png" alt="img"></p>
<h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
<li><a href="https://book.douban.com/subject/4496038/">Head First Java</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24556934?refer=dreawer">图解 Java 中的参数传递</a></li>
<li><a href="http://www.cnblogs.com/benwu/articles/5812903.html">Java 的 Finalizer 引发的内存溢出</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27850176">重载 Finalize 引发的内存泄露</a></li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java 泛型</title>
    <url>/2021/12/06/java-generic/</url>
    <content><![CDATA[<h1 id="深入理解-Java-泛型"><a href="#深入理解-Java-泛型" class="headerlink" title="深入理解 Java 泛型"></a>深入理解 Java 泛型</h1><blockquote>
<p><strong>📦 本文以及示例源码已归档在 <a href="https://github.com/dunwu/javacore/">javacore</a></strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->

<ul>
<li><a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B">1. 为什么需要泛型</a></li>
<li><a href="#2-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B">2. 泛型类型</a><ul>
<li><a href="#21-%E6%B3%9B%E5%9E%8B%E7%B1%BB">2.1. 泛型类</a></li>
<li><a href="#22-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3">2.2. 泛型接口</a></li>
</ul>
</li>
<li><a href="#3-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">3. 泛型方法</a></li>
<li><a href="#4-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">4. 类型擦除</a></li>
<li><a href="#5-%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF">5. 泛型和继承</a></li>
<li><a href="#6-%E7%B1%BB%E5%9E%8B%E8%BE%B9%E7%95%8C">6. 类型边界</a></li>
<li><a href="#7-%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6">7. 类型通配符</a><ul>
<li><a href="#71-%E4%B8%8A%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6">7.1. 上界通配符</a></li>
<li><a href="#72-%E4%B8%8B%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6">7.2. 下界通配符</a></li>
<li><a href="#73-%E6%97%A0%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6">7.3. 无界通配符</a></li>
<li><a href="#74-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B">7.4. 通配符和向上转型</a></li>
</ul>
</li>
<li><a href="#8-%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BA%A6%E6%9D%9F">8. 泛型的约束</a></li>
<li><a href="#9-%E6%B3%9B%E5%9E%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">9. 泛型最佳实践</a><ul>
<li><a href="#91-%E6%B3%9B%E5%9E%8B%E5%91%BD%E5%90%8D">9.1. 泛型命名</a></li>
<li><a href="#92-%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%BB%BA%E8%AE%AE">9.2. 使用泛型的建议</a></li>
</ul>
</li>
<li><a href="#10-%E5%B0%8F%E7%BB%93">10. 小结</a></li>
<li><a href="#11-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">11. 参考资料</a></li>
</ul>
<!-- /TOC -->

<h2 id="1-为什么需要泛型"><a href="#1-为什么需要泛型" class="headerlink" title="1. 为什么需要泛型"></a>1. 为什么需要泛型</h2><p><strong>JDK5 引入了泛型机制</strong>。</p>
<p>为什么需要泛型呢？回答这个问题前，先让我们来看一个示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoGenericsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="number">18</span>);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="keyword">double</span>[] &#123;<span class="number">1.0</span>, <span class="number">2.0</span>&#125;);</span><br><span class="line">        Object obj1 = list.get(<span class="number">0</span>);</span><br><span class="line">        Object obj2 = list.get(<span class="number">1</span>);</span><br><span class="line">        Object obj3 = list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;obj1 = [&quot;</span> + obj1 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;obj2 = [&quot;</span> + obj2 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;obj3 = [&quot;</span> + obj3 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num1 = (<span class="keyword">int</span>)list.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> num2 = (<span class="keyword">int</span>)list.get(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> num3 = (<span class="keyword">int</span>)list.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;num1 = [&quot;</span> + num1 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;num2 = [&quot;</span> + num2 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;num3 = [&quot;</span> + num3 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// obj1 = [abc]</span></span><br><span class="line"><span class="comment">// obj2 = [18]</span></span><br><span class="line"><span class="comment">// obj3 = [[D@47089e5f]</span></span><br><span class="line"><span class="comment">// Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer</span></span><br><span class="line"><span class="comment">// at io.github.dunwu.javacore.generics.NoGenericsDemo.main(NoGenericsDemo.java:23)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例说明：</p>
<p>在上面的示例中，<code>List</code> 容器没有指定存储数据类型，这种情况下，可以向 <code>List</code> 添加任意类型数据，编译器不会做类型检查，而是默默的将所有数据都转为 <code>Object</code>。</p>
<p>假设，最初我们希望向 <code>List</code> 存储的是整形数据，假设，某个家伙不小心存入了其他数据类型。当你试图从容器中取整形数据时，由于 <code>List</code> 当成 <code>Object</code> 类型来存储，你不得不使用类型强制转换。在运行时，才会发现 <code>List</code> 中数据不存储一致的问题，这就为程序运行带来了很大的风险（无形伤害最为致命）。</p>
</blockquote>
<p>而泛型的出现，解决了类型安全问题。</p>
<p>泛型具有以下优点：</p>
<ul>
<li><strong>编译时的强类型检查</strong></li>
</ul>
<p>泛型要求在声明时指定实际数据类型，Java 编译器在编译时会对泛型代码做强类型检查，并在代码违反类型安全时发出告警。早发现，早治理，把隐患扼杀于摇篮，在编译时发现并修复错误所付出的代价远比在运行时小。</p>
<ul>
<li><strong>避免了类型转换</strong></li>
</ul>
<p>未使用泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String s = (String) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>使用泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String s = list.get(<span class="number">0</span>);   <span class="comment">// no cast</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>泛型编程可以实现通用算法</strong></li>
</ul>
<p>通过使用泛型，程序员可以实现通用算法，这些算法可以处理不同类型的集合，可以自定义，并且类型安全且易于阅读。</p>
<h2 id="2-泛型类型"><a href="#2-泛型类型" class="headerlink" title="2. 泛型类型"></a>2. 泛型类型</h2><p><strong><code>泛型类型</code>是被参数化的类或接口。</strong></p>
<h3 id="2-1-泛型类"><a href="#2-1-泛型类" class="headerlink" title="2.1. 泛型类"></a>2.1. 泛型类</h3><p>泛型类的语法形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">name</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, ..., <span class="title">Tn</span>&gt; </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。由尖括号（<code>&lt;&gt;</code>）分隔的类型参数部分跟在类名后面。它指定类型参数（也称为类型变量）T1，T2，…和 Tn。</p>
<p>一般将泛型中的类名称为<strong>原型</strong>，而将 <code>&lt;&gt;</code> 指定的参数称为<strong>类型参数</strong>。</p>
<ul>
<li>未应用泛型的类</li>
</ul>
<p>在泛型出现之前，如果一个类想持有一个可以为任意类型的数据，只能使用 <code>Object</code> 做类型转换。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>单类型参数的泛型类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Info&#123;&quot;</span> + <span class="string">&quot;value=&quot;</span> + value + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsClassDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Info&lt;Integer&gt; info = <span class="keyword">new</span> Info&lt;&gt;();</span><br><span class="line">        info.setValue(<span class="number">10</span>);</span><br><span class="line">        System.out.println(info.getValue());</span><br><span class="line"></span><br><span class="line">        Info&lt;String&gt; info2 = <span class="keyword">new</span> Info&lt;&gt;();</span><br><span class="line">        info2.setValue(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        System.out.println(info2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// xyz</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，在初始化一个泛型类时，使用 <code>&lt;&gt;</code> 指定了内部具体类型，在编译时就会根据这个类型做强类型检查。</p>
<p>实际上，不使用 <code>&lt;&gt;</code> 指定内部具体类型，语法上也是支持的（不推荐这么做），如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Info info = <span class="keyword">new</span> Info();</span><br><span class="line">    info.setValue(<span class="number">10</span>);</span><br><span class="line">    System.out.println(info.getValue());</span><br><span class="line">    info.setValue(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    System.out.println(info.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例说明：</p>
<p>上面的例子，不会产生编译错误，也能正常运行。但这样的调用就失去泛型类型的优势。</p>
</blockquote>
<ul>
<li>多个类型参数的泛型类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMap</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyMap&#123;&quot;</span> + <span class="string">&quot;key=&quot;</span> + key + <span class="string">&quot;, value=&quot;</span> + value + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsClassDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyMap&lt;Integer, String&gt; map = <span class="keyword">new</span> MyMap&lt;&gt;(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// MyMap&#123;key=1, value=one&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>泛型类的类型嵌套</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsClassDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Info&lt;String&gt; info = <span class="keyword">new</span> Info(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        MyMap&lt;Integer, Info&lt;String&gt;&gt; map = <span class="keyword">new</span> MyMap&lt;&gt;(<span class="number">1</span>, info);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// MyMap&#123;key=1, value=Info&#123;value=Hello&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-泛型接口"><a href="#2-2-泛型接口" class="headerlink" title="2.2. 泛型接口"></a>2.2. 泛型接口</h3><p>接口也可以声明泛型。</p>
<p>泛型接口语法形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Content</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">text</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型接口有两种实现方式：</p>
<ul>
<li>实现接口的子类明确声明泛型类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsInterfaceDemo01</span> <span class="keyword">implements</span> <span class="title">Content</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericsInterfaceDemo01</span><span class="params">(<span class="keyword">int</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">text</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> text; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericsInterfaceDemo01 demo = <span class="keyword">new</span> GenericsInterfaceDemo01(<span class="number">10</span>);</span><br><span class="line">        System.out.print(demo.text());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现接口的子类不明确声明泛型类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsInterfaceDemo02</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Content</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericsInterfaceDemo02</span><span class="params">(T text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">text</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> text; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericsInterfaceDemo02&lt;String&gt; gen = <span class="keyword">new</span> GenericsInterfaceDemo02&lt;&gt;(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">        System.out.print(gen.text());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// ABC</span></span><br></pre></td></tr></table></figure>

<h2 id="3-泛型方法"><a href="#3-泛型方法" class="headerlink" title="3. 泛型方法"></a>3. 泛型方法</h2><p>泛型方法是引入其自己的类型参数的方法。泛型方法可以是普通方法、静态方法以及构造方法。</p>
<p>泛型方法语法形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">func</span><span class="params">(T obj)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>是否拥有泛型方法，与其所在的类是否是泛型没有关系。</strong></p>
<p>泛型方法的语法包括一个类型参数列表，在尖括号内，它出现在方法的返回类型之前。对于静态泛型方法，类型参数部分必须出现在方法的返回类型之前。类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际类型参数的占位符。</p>
<p><strong>使用泛型方法的时候，通常不必指明类型参数，因为编译器会为我们找出具体的类型。这称为类型参数推断（type argument inference）。类型推断只对赋值操作有效，其他时候并不起作用</strong>。如果将一个泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行推断。编译器会认为：调用泛型方法后，其返回值被赋给一个 Object 类型的变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsMethodDemo01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printClass</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        System.out.println(obj.getClass().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printClass(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        printClass(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// class java.lang.String</span></span><br><span class="line"><span class="comment">// class java.lang.Integer</span></span><br></pre></td></tr></table></figure>

<p>泛型方法中也可以使用可变参数列表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargsMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        Collections.addAll(result, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ls = makeList(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// [A]</span></span><br><span class="line"><span class="comment">// [A, B, C]</span></span><br></pre></td></tr></table></figure>

<h2 id="4-类型擦除"><a href="#4-类型擦除" class="headerlink" title="4. 类型擦除"></a>4. 类型擦除</h2><p>Java 语言引入泛型是为了在编译时提供更严格的类型检查，并支持泛型编程。不同于 C++ 的模板机制，<strong>Java 泛型是使用类型擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了</strong>。</p>
<p>那么，类型擦除做了什么呢？它做了以下工作：</p>
<ul>
<li>把泛型中的所有类型参数替换为 Object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。</li>
<li>擦除出现的类型声明，即去掉 <code>&lt;&gt;</code> 的内容。比如 <code>T get()</code> 方法声明就变成了 <code>Object get()</code> ；<code>List&lt;String&gt;</code> 就变成了 <code>List</code>。如有必要，插入类型转换以保持类型安全。</li>
<li>生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销。</li>
</ul>
<p>让我们来看一个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsErasureTypeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        System.out.println(list1.getClass());</span><br><span class="line">        System.out.println(list2.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// class java.util.ArrayList</span></span><br><span class="line"><span class="comment">// class java.util.ArrayList</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例说明：</p>
<p>上面的例子中，虽然指定了不同的类型参数，但是 list1 和 list2 的类信息却是一样的。</p>
<p>这是因为：<strong>使用泛型时，任何具体的类型信息都被擦除了</strong>。这意味着：<code>ArrayList&lt;Object&gt;</code> 和 <code>ArrayList&lt;String&gt;</code> 在运行时，JVM 将它们视为同一类型。</p>
</blockquote>
<p>Java 泛型的实现方式不太优雅，但这是因为泛型是在 JDK5 时引入的，为了兼容老代码，必须在设计上做一定的折中。</p>
<h2 id="5-泛型和继承"><a href="#5-泛型和继承" class="headerlink" title="5. 泛型和继承"></a>5. 泛型和继承</h2><p><strong>泛型不能用于显式地引用运行时类型的操作之中，例如：转型、instanceof 操作和 new 表达式。因为所有关于参数的类型信息都丢失了</strong>。当你在编写泛型代码时，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已。</p>
<p>正是由于泛型时基于类型擦除实现的，所以，<strong>泛型类型无法向上转型</strong>。</p>
<blockquote>
<p>向上转型是指用子类实例去初始化父类，这是面向对象中多态的重要表现。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1553147778883.png" alt="img"></p>
<p><code>Integer</code> 继承了 <code>Object</code>；<code>ArrayList</code> 继承了 <code>List</code>；但是 <code>List&lt;Interger&gt;</code> 却并非继承了 <code>List&lt;Object&gt;</code>。</p>
<p>这是因为，泛型类并没有自己独有的 <code>Class</code> 类对象。比如：并不存在 <code>List&lt;Object&gt;.class</code> 或是 <code>List&lt;Interger&gt;.class</code>，Java 编译器会将二者都视为 <code>List.class</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; list2 = list; <span class="comment">// Erorr</span></span><br></pre></td></tr></table></figure>

<h2 id="6-类型边界"><a href="#6-类型边界" class="headerlink" title="6. 类型边界"></a>6. 类型边界</h2><p>有时您可能希望限制可在参数化类型中用作类型参数的类型。**<code>类型边界</code>可以对泛型的类型参数设置限制条件**。例如，对数字进行操作的方法可能只想接受 <code>Number</code> 或其子类的实例。</p>
<p>要声明有界类型参数，请列出类型参数的名称，然后是 <code>extends</code> 关键字，后跟其限制类或接口。</p>
<p>类型边界的语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;T extends XXX&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsExtendsDemo01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(T x, T y, T z)</span> </span>&#123;</span><br><span class="line">        T max = x; <span class="comment">// 假设x是初始最大值</span></span><br><span class="line">        <span class="keyword">if</span> (y.compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = y; <span class="comment">//y 更大</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (z.compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            max = z; <span class="comment">// 现在 z 更大</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max; <span class="comment">// 返回最大对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(max(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">        System.out.println(max(<span class="number">6.6</span>, <span class="number">8.8</span>, <span class="number">7.7</span>));</span><br><span class="line">        System.out.println(max(<span class="string">&quot;pear&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 8.8</span></span><br><span class="line"><span class="comment">// pear</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>示例说明：</p>
<p>上面的示例声明了一个泛型方法，类型参数 <code>T extends Comparable&lt;T&gt;</code> 表明传入方法中的类型必须实现了 Comparable 接口。</p>
</blockquote>
<p>类型边界可以设置多个，语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;T extends B1 &amp; B2 &amp; B3&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>🔔 注意：extends 关键字后面的第一个类型参数可以是类或接口，其他类型参数只能是接口。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsExtendsDemo02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">C</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">D1</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span> &amp; <span class="title">B</span> &amp; <span class="title">C</span>&gt; </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">D2</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">B</span> &amp; <span class="title">A</span> &amp; <span class="title">C</span>&gt; </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// 编译报错</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">B</span>, <span class="title">C</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        D1&lt;E&gt; demo1 = <span class="keyword">new</span> D1&lt;&gt;();</span><br><span class="line">        System.out.println(demo1.getClass().toString());</span><br><span class="line">        D1&lt;String&gt; demo2 = <span class="keyword">new</span> D1&lt;&gt;(); <span class="comment">// 编译报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-类型通配符"><a href="#7-类型通配符" class="headerlink" title="7. 类型通配符"></a>7. 类型通配符</h2><p><code>类型通配符</code>一般是使用 <code>?</code> 代替具体的类型参数。例如 <code>List&lt;?&gt;</code> 在逻辑上是 <code>List&lt;String&gt;</code> ，<code>List&lt;Integer&gt;</code> 等所有 <code>List&lt;具体类型实参&gt;</code> 的父类。</p>
<h3 id="7-1-上界通配符"><a href="#7-1-上界通配符" class="headerlink" title="7.1. 上界通配符"></a>7.1. 上界通配符</h3><p>可以使用**<code>上界通配符</code>**来缩小类型参数的类型范围。</p>
<p>它的语法形式为：<code>&lt;? extends Number&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsUpperBoundedWildcardDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sumOfList</span><span class="params">(List&lt;? extends Number&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> s = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Number n : list) &#123;</span><br><span class="line">            s += n.doubleValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; li = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sum = &quot;</span> + sumOfList(li));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// sum = 6.0</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-下界通配符"><a href="#7-2-下界通配符" class="headerlink" title="7.2. 下界通配符"></a>7.2. 下界通配符</h3><p>**<code>下界通配符</code>**将未知类型限制为该类型的特定类型或超类类型。</p>
<blockquote>
<p>🔔 注意：<strong>上界通配符和下界通配符不能同时使用</strong>。</p>
</blockquote>
<p>它的语法形式为：<code>&lt;? super Number&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsLowerBoundedWildcardDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNumbers</span><span class="params">(List&lt;? <span class="keyword">super</span> Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        addNumbers(list);</span><br><span class="line">        System.out.println(Arrays.deepToString(list.toArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="7-3-无界通配符"><a href="#7-3-无界通配符" class="headerlink" title="7.3. 无界通配符"></a>7.3. 无界通配符</h3><p>无界通配符有两种应用场景：</p>
<ul>
<li>可以使用 Object 类中提供的功能来实现的方法。</li>
<li>使用不依赖于类型参数的泛型类中的方法。</li>
</ul>
<p>语法形式：<code>&lt;?&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsUnboundedWildcardDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object elem : list) &#123;</span><br><span class="line">            System.out.print(elem + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; li = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        List&lt;String&gt; ls = Arrays.asList(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        printList(li);</span><br><span class="line">        printList(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// one two three</span></span><br></pre></td></tr></table></figure>

<h3 id="7-4-通配符和向上转型"><a href="#7-4-通配符和向上转型" class="headerlink" title="7.4. 通配符和向上转型"></a>7.4. 通配符和向上转型</h3><p>前面，我们提到：<strong>泛型不能向上转型。但是，我们可以通过使用通配符来向上转型</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsWildcardDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Number&gt; numList = intList;  <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line">        List&lt;? extends Integer&gt; intList2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;? extends Number&gt; numList2 = intList2;  <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展阅读：<a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">Oracle 泛型文档</a></p>
</blockquote>
<h2 id="8-泛型的约束"><a href="#8-泛型的约束" class="headerlink" title="8. 泛型的约束"></a>8. 泛型的约束</h2><ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#instantiate">泛型类型的类型参数不能是值类型</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">8</span>, <span class="string">&#x27;a&#x27;</span>);  <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createObjects">不能创建类型参数的实例</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">    E elem = <span class="keyword">new</span> E();  <span class="comment">// 编译错误</span></span><br><span class="line">    list.add(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createStatic">不能声明类型为类型参数的静态成员</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileDevice</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T os; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotCast">类型参数不能使用类型转换或 <code>instanceof</code></a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">rtti</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> ArrayList&lt;Integer&gt;) &#123;  <span class="comment">// 编译错误</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt;  ln = (List&lt;Number&gt;) li;  <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createArrays">不能创建类型参数的数组</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt;[] arrayOfLists = <span class="keyword">new</span> List&lt;Integer&gt;[<span class="number">2</span>];  <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotCatch">不能创建、catch 或 throw 参数化类型对象</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Extends Throwable indirectly</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathException</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; <span class="comment">/* ... */</span> &#125;    <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Extends Throwable directly</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueFullException</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Throwable</span> </span>&#123; <span class="comment">/* ... */</span> <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Exception, J&gt; <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(List&lt;J&gt; jobs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (J job : jobs)</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (T e) &#123;   <span class="comment">// compile-time error</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#cannotOverload">仅仅是泛型类相同，而类型参数不同的方法不能重载</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;String&gt; strSet)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Set&lt;Integer&gt; intSet)</span> </span>&#123; &#125; <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-泛型最佳实践"><a href="#9-泛型最佳实践" class="headerlink" title="9. 泛型最佳实践"></a>9. 泛型最佳实践</h2><h3 id="9-1-泛型命名"><a href="#9-1-泛型命名" class="headerlink" title="9.1. 泛型命名"></a>9.1. 泛型命名</h3><p>泛型一些约定俗成的命名：</p>
<ul>
<li>E - Element</li>
<li>K - Key</li>
<li>N - Number</li>
<li>T - Type</li>
<li>V - Value</li>
<li>S,U,V etc. - 2nd, 3rd, 4th types</li>
</ul>
<h3 id="9-2-使用泛型的建议"><a href="#9-2-使用泛型的建议" class="headerlink" title="9.2. 使用泛型的建议"></a>9.2. 使用泛型的建议</h3><ul>
<li>消除类型检查告警</li>
<li>List 优先于数组</li>
<li>优先考虑使用泛型来提高代码通用性</li>
<li>优先考虑泛型方法来限定泛型的范围</li>
<li>利用有限制通配符来提升 API 的灵活性</li>
<li>优先考虑类型安全的异构容器</li>
</ul>
<h2 id="10-小结"><a href="#10-小结" class="headerlink" title="10. 小结"></a>10. 小结</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/Java%E6%B3%9B%E5%9E%8B.svg" alt="img"></p>
<h2 id="11-参考资料"><a href="#11-参考资料" class="headerlink" title="11. 参考资料"></a>11. 参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
<li><a href="https://book.douban.com/subject/3360807/">Effective java</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">Oracle 泛型文档</a></li>
<li><a href="https://juejin.im/post/584d36f161ff4b006cccdb82">Java 泛型详解</a></li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>范型</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java 异常</title>
    <url>/2021/12/06/java-exception/</url>
    <content><![CDATA[<h1 id="深入理解-Java-异常"><a href="#深入理解-Java-异常" class="headerlink" title="深入理解 Java 异常"></a>深入理解 Java 异常</h1><blockquote>
<p><strong>📦 本文以及示例源码已归档在 <a href="https://github.com/dunwu/javacore/">javacore</a></strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1553752019030.png" alt="img"></p>
<!-- TOC depthFrom:2 depthTo:3 -->

<ul>
<li><a href="#1-%E5%BC%82%E5%B8%B8%E6%A1%86%E6%9E%B6">1. 异常框架</a><ul>
<li><a href="#11-throwable">1.1. Throwable</a></li>
<li><a href="#12-error">1.2. Error</a></li>
<li><a href="#13-exception">1.3. Exception</a></li>
<li><a href="#14-runtimeexception">1.4. RuntimeException</a></li>
</ul>
</li>
<li><a href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8">2. 自定义异常</a></li>
<li><a href="#3-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8">3. 抛出异常</a></li>
<li><a href="#4-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8">4. 捕获异常</a></li>
<li><a href="#5-%E5%BC%82%E5%B8%B8%E9%93%BE">5. 异常链</a></li>
<li><a href="#6-%E5%BC%82%E5%B8%B8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">6. 异常注意事项</a><ul>
<li><a href="#61-finally-%E8%A6%86%E7%9B%96%E5%BC%82%E5%B8%B8">6.1. finally 覆盖异常</a></li>
<li><a href="#62-%E8%A6%86%E7%9B%96%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84%E6%96%B9%E6%B3%95">6.2. 覆盖抛出异常的方法</a></li>
<li><a href="#63-%E5%BC%82%E5%B8%B8%E5%92%8C%E7%BA%BF%E7%A8%8B">6.3. 异常和线程</a></li>
</ul>
</li>
<li><a href="#7-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">7. 最佳实践</a></li>
<li><a href="#8-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">8. 参考资料</a></li>
</ul>
<!-- /TOC -->

<h2 id="1-异常框架"><a href="#1-异常框架" class="headerlink" title="1. 异常框架"></a>1. 异常框架</h2><h3 id="1-1-Throwable"><a href="#1-1-Throwable" class="headerlink" title="1.1. Throwable"></a>1.1. Throwable</h3><p><strong><code>Throwable</code> 是 Java 语言中所有错误（<code>Error</code>）和异常（<code>Exception</code>）的超类。</strong>在 Java 中只有 <code>Throwable</code> 类型的实例才可以被抛出（<code>throw</code>）或者捕获（<code>catch</code>），它是异常处理机制的基本组成类型。</p>
<p><code>Throwable</code> 包含了其线程创建时线程执行堆栈的快照，它提供了 <code>printStackTrace()</code> 等接口用于获取堆栈跟踪数据等信息。</p>
<p>主要方法：</p>
<ul>
<li><code>fillInStackTrace</code> - 用当前的调用栈层次填充 <code>Throwable</code> 对象栈层次，添加到栈层次任何先前信息中。</li>
<li><code>getMessage</code> - 返回关于发生的异常的详细信息。这个消息在 <code>Throwable</code> 类的构造函数中初始化了。</li>
<li><code>getCause</code> - 返回一个 <code>Throwable</code> 对象代表异常原因。</li>
<li><code>getStackTrace</code> - 返回一个包含堆栈层次的数组。下标为 0 的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</li>
<li><code>printStackTrace</code> - 打印 <code>toString()</code> 结果和栈层次到 <code>System.err</code>，即错误输出流。</li>
<li><code>toString</code> - 使用 <code>getMessage</code> 的结果返回代表 <code>Throwable</code> 对象的字符串。</li>
</ul>
<h3 id="1-2-Error"><a href="#1-2-Error" class="headerlink" title="1.2. Error"></a>1.2. Error</h3><p><code>Error</code> 是 <code>Throwable</code> 的一个子类。**<code>Error</code> 表示正常情况下，不大可能出现的严重问题<strong>。</strong>编译器不会检查 <code>Error</code>**。绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。</p>
<p>常见 <code>Error</code>：</p>
<ul>
<li><code>AssertionError</code> - 断言错误。</li>
<li><code>VirtualMachineError</code> - 虚拟机错误。</li>
<li><code>UnsupportedClassVersionError</code> - Java 类版本错误。</li>
<li><code>StackOverflowError</code> - 栈溢出错误。</li>
<li><code>OutOfMemoryError</code> - 内存溢出错误。</li>
</ul>
<h3 id="1-3-Exception"><a href="#1-3-Exception" class="headerlink" title="1.3. Exception"></a>1.3. Exception</h3><p><code>Exception</code> 是 <code>Throwable</code> 的一个子类。**<code>Exception</code> 表示合理的应用程序可能想要捕获的条件。**Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</p>
<p>Exception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。</p>
<p><strong>编译器会检查 <code>Exception</code> 异常。</strong>此类异常，要么通过 <code>throws</code> 进行声明抛出，要么通过 <code>try catch</code> 进行捕获处理，否则不能通过编译。</p>
<p>常见 <code>Exception</code>：</p>
<ul>
<li><code>ClassNotFoundException</code> - 应用程序试图加载类时，找不到相应的类，抛出该异常。</li>
<li><code>CloneNotSupportedException</code> - 当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。</li>
<li><code>IllegalAccessException</code> - 拒绝访问一个类的时候，抛出该异常。</li>
<li><code>InstantiationException</code> - 当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</li>
<li><code>InterruptedException</code> - 一个线程被另一个线程中断，抛出该异常。</li>
<li><code>NoSuchFieldException</code> - 请求的变量不存在。</li>
<li><code>NoSuchMethodException</code> - 请求的方法不存在。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Method method = String.class.getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>试图编译运行时会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error:(7, 47) java: 未报告的异常错误java.lang.NoSuchMethodException; 必须对其进行捕获或声明以便抛出</span><br></pre></td></tr></table></figure>

<h3 id="1-4-RuntimeException"><a href="#1-4-RuntimeException" class="headerlink" title="1.4. RuntimeException"></a>1.4. RuntimeException</h3><p><code>RuntimeException</code> 是 <code>Exception</code> 的一个子类。<code>RuntimeException</code> 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。</p>
<p><strong>编译器不会检查 <code>RuntimeException</code> 异常。</strong>当程序中可能出现这类异常时，倘若既没有通过 <code>throws</code> 声明抛出它，也没有用 <code>try catch</code> 语句捕获它，程序还是会编译通过。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处产生了异常</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;两个数字相除的结果：&quot;</span> + result);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行时输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">	at io.github.dunwu.javacore.exception.RumtimeExceptionDemo01.main(RumtimeExceptionDemo01.java:6)</span><br></pre></td></tr></table></figure>

<p>常见 <code>RuntimeException</code>：</p>
<ul>
<li><code>ArrayIndexOutOfBoundsException</code> - 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</li>
<li><code>ArrayStoreException</code> - 试图将错误类型的对象存储到一个对象数组时抛出的异常。</li>
<li><code>ClassCastException</code> - 当试图将对象强制转换为不是实例的子类时，抛出该异常。</li>
<li><code>IllegalArgumentException</code> - 抛出的异常表明向方法传递了一个不合法或不正确的参数。</li>
<li><code>IllegalMonitorStateException</code> - 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</li>
<li><code>IllegalStateException</code> - 在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</li>
<li><code>IllegalThreadStateException</code> - 线程没有处于请求操作所要求的适当状态时抛出的异常。</li>
<li><code>IndexOutOfBoundsException</code> - 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li>
<li><code>NegativeArraySizeException</code> - 如果应用程序试图创建大小为负的数组，则抛出该异常。</li>
<li><code>NullPointerException</code> - 当应用程序试图在需要对象的地方使用 null 时，抛出该异常</li>
<li><code>NumberFormatException</code> - 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li>
<li><code>SecurityException</code> - 由安全管理器抛出的异常，指示存在安全侵犯。</li>
<li><code>StringIndexOutOfBoundsException</code> - 此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。</li>
<li><code>UnsupportedOperationException</code> - 当不支持请求的操作时，抛出该异常。</li>
</ul>
<h2 id="2-自定义异常"><a href="#2-自定义异常" class="headerlink" title="2. 自定义异常"></a>2. 自定义异常</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1553752795010.png" alt="img"></p>
<p><strong>自定义一个异常类，只需要继承 <code>Exception</code> 或 <code>RuntimeException</code> 即可。</strong></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">&quot;自定义异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; io.github.dunwu.javacore.exception.MyExceptionDemo$MyException: 自定义异常</span><br><span class="line">	at io.github.dunwu.javacore.exception.MyExceptionDemo.main(MyExceptionDemo.java:9)</span><br></pre></td></tr></table></figure>

<h2 id="3-抛出异常"><a href="#3-抛出异常" class="headerlink" title="3. 抛出异常"></a>3. 抛出异常</h2><p>如果想在程序中明确地抛出异常，需要用到 <code>throw</code> 和 <code>throws</code> 。</p>
<p>如果一个方法没有捕获一个检查性异常，那么该方法必须使用 <code>throws</code> 关键字来声明。<code>throws</code> 关键字放在方法签名的尾部。</p>
<p><code>throw</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;抛出一个异常&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.RuntimeException: 抛出一个异常</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>throw</code> 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p>
<p><code>throws</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, NoSuchFieldException </span>&#123;</span><br><span class="line">        Field field = Integer.class.getDeclaredField(<span class="string">&quot;digits&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (field != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;反射获取 digits 方法成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Method method = String.class.getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;反射获取 toString 方法成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 f1 处，如果不用 try catch ，编译时会报错</span></span><br><span class="line">            f1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        f2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反射获取 digits 方法成功</span><br><span class="line">java.lang.NoSuchMethodException: java.lang.String.toString(int)</span><br><span class="line">	at java.lang.Class.getMethod(Class.java:1786)</span><br><span class="line">	at io.github.dunwu.javacore.exception.ThrowsDemo.f1(ThrowsDemo.java:12)</span><br><span class="line">	at io.github.dunwu.javacore.exception.ThrowsDemo.f2(ThrowsDemo.java:21)</span><br><span class="line">	at io.github.dunwu.javacore.exception.ThrowsDemo.main(ThrowsDemo.java:30)</span><br></pre></td></tr></table></figure>

<p>throw 和 throws 的区别：</p>
<ul>
<li>throws 使用在函数上，throw 使用在函数内。</li>
<li>throws 后面跟异常类，可以跟多个，用逗号区别；throw 后面跟的是异常对象。</li>
</ul>
<h2 id="4-捕获异常"><a href="#4-捕获异常" class="headerlink" title="4. 捕获异常"></a>4. 捕获异常</h2><p><strong>使用 try 和 catch 关键字可以捕获异常</strong>。try catch 代码块放在异常可能发生的地方。</p>
<p>它的语法形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会发生异常的代码块</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">    <span class="comment">// 捕获并处理try抛出的异常类型Exception</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception2 e2) &#123;</span><br><span class="line">    <span class="comment">// 捕获并处理try抛出的异常类型Exception2</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都将执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，JDK7 以后，<code>catch</code> 多种异常时，也可以像下面这样简化代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能会发生异常的代码块</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception | Exception2 e) &#123;</span><br><span class="line">    <span class="comment">// 捕获并处理try抛出的异常类型</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都将执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>try</code> - <strong><code>try</code> 语句用于监听。将要被监听的代码(可能抛出异常的代码)放在 <code>try</code> 语句块之内，当 <code>try</code> 语句块内发生异常时，异常就被抛出。</strong></li>
<li><code>catch</code> - <code>catch</code> 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，<code>try</code> 后面的 <code>catch</code> 块就会被检查。</li>
<li><code>finally</code> - <strong><code>finally</code> 语句块总是会被执行，无论是否出现异常。</strong><code>try catch</code> 语句后不一定非要 <code>finally</code> 语句。<code>finally</code> 常用于这样的场景：由于 <code>finally</code> 语句块总是会被执行，所以那些在 <code>try</code> 代码块中打开的，并且必须回收的物理资源(如数据库连接、网络连接和文件)，一般会放在 <code>finally</code> 语句块中释放资源。</li>
<li><code>try</code>、<code>catch</code>、<code>finally</code> 三个代码块中的局部变量不可共享使用。</li>
<li><code>catch</code> 块尝试捕获异常时，是按照 <code>catch</code> 块的声明顺序从上往下寻找的，一旦匹配，就不会再向下执行。因此，如果同一个 <code>try</code> 块下的多个 <code>catch</code> 异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchFinallyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 此处产生了异常</span></span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;两个数字相除的结果：&quot;</span> + temp);</span><br><span class="line">            System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出现异常了：&quot;</span> + e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不管是否出现异常，都执行此代码&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行时输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">出现异常了：java.lang.ArithmeticException: / by zero</span><br><span class="line">不管是否出现异常，都执行此代码</span><br></pre></td></tr></table></figure>

<h2 id="5-异常链"><a href="#5-异常链" class="headerlink" title="5. 异常链"></a>5. 异常链</h2><p>异常链是以一个异常对象为参数构造新的异常对象，新的异常对象将包含先前异常的信息。</p>
<p>通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。</p>
<p>我们有两种方式处理异常，一是 <code>throws</code> 抛出交给上级处理，二是 <code>try…catch</code> 做具体处理。<code>try…catch</code> 的 <code>catch</code> 块我们可以不需要做任何处理，仅仅只用 throw 这个关键字将我们封装异常信息主动抛出来。然后在通过关键字 <code>throws</code> 继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。</p>
<p>【示例】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionChainDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException1</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyException1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException2</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyException2</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(message, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">throws</span> MyException1 </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException1(<span class="string">&quot;出现 MyException1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> <span class="keyword">throws</span> MyException2 </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException1 e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException2(<span class="string">&quot;出现 MyException2&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MyException2 </span>&#123;</span><br><span class="line">        f2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; io.github.dunwu.javacore.exception.ExceptionChainDemo$MyException2: 出现 MyException2</span><br><span class="line">	at io.github.dunwu.javacore.exception.ExceptionChainDemo.f2(ExceptionChainDemo.java:29)</span><br><span class="line">	at io.github.dunwu.javacore.exception.ExceptionChainDemo.main(ExceptionChainDemo.java:34)</span><br><span class="line">Caused by: io.github.dunwu.javacore.exception.ExceptionChainDemo$MyException1: 出现 MyException1</span><br><span class="line">	at io.github.dunwu.javacore.exception.ExceptionChainDemo.f1(ExceptionChainDemo.java:22)</span><br><span class="line">	at io.github.dunwu.javacore.exception.ExceptionChainDemo.f2(ExceptionChainDemo.java:27)</span><br><span class="line">	... 1 more</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展阅读：<a href="https://juejin.im/post/5b6d61e55188251b38129f9a#heading-10">https://juejin.im/post/5b6d61e55188251b38129f9a#heading-10</a></p>
<p>这篇文章中对于异常链讲解比较详细。</p>
</blockquote>
<h2 id="6-异常注意事项"><a href="#6-异常注意事项" class="headerlink" title="6. 异常注意事项"></a>6. 异常注意事项</h2><h3 id="6-1-finally-覆盖异常"><a href="#6-1-finally-覆盖异常" class="headerlink" title="6.1. finally 覆盖异常"></a>6.1. finally 覆盖异常</h3><p>Java 异常处理中 <code>finally</code> 中的 <code>return</code> 会覆盖 <code>catch</code> 代码块中的 <code>return</code> 语句和 <code>throw</code> 语句，所以 Java <strong>不建议在 <code>finally</code> 中使用 <code>return</code> 语句</strong>。</p>
<p>此外 <code>finally</code> 中的 <code>throw</code> 语句也会覆盖 <code>catch</code> 代码块中的 <code>return</code> 语句和 <code>throw</code> 语句。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyOverrideExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：C</p>
<h3 id="6-2-覆盖抛出异常的方法"><a href="#6-2-覆盖抛出异常的方法" class="headerlink" title="6.2. 覆盖抛出异常的方法"></a>6.2. 覆盖抛出异常的方法</h3><p>当子类重写父类带有 <code>throws</code> 声明的函数时，其 <code>throws</code> 声明的异常必须在父类异常的可控范围内——用于处理父类的 <code>throws</code> 方法的异常处理器，必须也适用于子类的这个带 <code>throws</code> 方法 。这是为了支持多态。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionOverrideDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father obj1 = <span class="keyword">new</span> Father();</span><br><span class="line">        Father obj2 = <span class="keyword">new</span> Son();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj1.start();</span><br><span class="line">            obj2.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的示例编译时会报错，原因在于：</p>
<p>因为 Son 类抛出异常的实质是 <code>SQLException</code>，而 <code>IOException</code> 无法处理它。那么这里的 try catch 就不能处理 Son 中的异常了。多态就不能实现了。</p>
</blockquote>
<h3 id="6-3-异常和线程"><a href="#6-3-异常和线程" class="headerlink" title="6.3. 异常和线程"></a>6.3. 异常和线程</h3><p>如果 Java 程序只有一个线程，那么没有被任何代码处理的异常会导致程序终止。如果 Java 程序是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。</p>
<h2 id="7-最佳实践"><a href="#7-最佳实践" class="headerlink" title="7. 最佳实践"></a>7. 最佳实践</h2><ul>
<li>对可恢复的情况使用检查性异常（Exception），对编程错误使用运行时异常（RuntimeException）。</li>
<li>优先使用 Java 标准的异常。</li>
<li>抛出与抽象相对应的异常。</li>
<li>在细节消息中包含能捕获失败的信息。</li>
<li>尽可能减少 try 代码块的大小。</li>
<li>尽量缩小异常范围。例如，如果明知尝试捕获的是一个 <code>ArithmeticException</code>，就应该 <code>catchArithmeticException</code>，而不是 <code>catch</code> 范围较大的 <code>RuntimeException</code>，甚至是 <code>Exception</code>。</li>
<li>尽量不要在 <code>finally</code> 块抛出异常或者返回值。</li>
<li>不要忽略异常，一旦捕获异常，就应该处理，而非丢弃。</li>
<li>异常处理效率很低，所以不要用异常进行业务逻辑处理。</li>
<li>各类异常必须要有单独的日志记录，将异常分级，分类管理，因为有的时候仅仅想给第三方运维看到逻辑异常，而不是更细节的信息。</li>
<li>如何对异常进行分类：<ul>
<li>逻辑异常，这类异常用于描述业务无法按照预期的情况处理下去，属于用户制造的意外。</li>
<li>代码错误，这类异常用于描述开发的代码错误，例如 NPE，ILLARG，都属于程序员制造的 BUG。</li>
<li>专有异常，多用于特定业务场景，用于描述指定作业出现意外情况无法预先处理。</li>
</ul>
</li>
</ul>
<blockquote>
<p>扩展阅读：</p>
<ul>
<li><a href="https://book.douban.com/subject/3360807/">Effective java 中文版 之 第九章 异常</a></li>
<li><a href="https://my.oschina.net/c5ms/blog/1827907">优雅的处理你的 Java 异常</a></li>
</ul>
</blockquote>
<h2 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8. 参考资料"></a>8. 参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
<li><a href="https://book.douban.com/subject/3360807/">Effective java 中文版 之 第九章 异常</a></li>
<li><a href="https://my.oschina.net/c5ms/blog/1827907">优雅的处理你的 Java 异常</a></li>
<li><a href="https://juejin.im/post/5b6d61e55188251b38129f9a#heading-17">https://juejin.im/post/5b6d61e55188251b38129f9a#heading-17</a></li>
<li><a href="https://www.cnblogs.com/skywang12345/p/3544168.html">https://www.cnblogs.com/skywang12345/p/3544168.html</a></li>
<li><a href="http://www.importnew.com/26613.html">http://www.importnew.com/26613.html</a></li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java 枚举</title>
    <url>/2021/12/06/java-enum/</url>
    <content><![CDATA[<h1 id="深入理解-Java-枚举"><a href="#深入理解-Java-枚举" class="headerlink" title="深入理解 Java 枚举"></a>深入理解 Java 枚举</h1><blockquote>
<p><strong>📦 本文以及示例源码已归档在 <a href="https://github.com/dunwu/javacore/">javacore</a></strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->

<ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B">1. 简介</a></li>
<li><a href="#2-%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%9C%AC%E8%B4%A8">2. 枚举的本质</a></li>
<li><a href="#3-%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%96%B9%E6%B3%95">3. 枚举的方法</a></li>
<li><a href="#4-%E6%9E%9A%E4%B8%BE%E7%9A%84%E7%89%B9%E6%80%A7">4. 枚举的特性</a><ul>
<li><a href="#41-%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7">4.1. 基本特性</a></li>
<li><a href="#42-%E6%9E%9A%E4%B8%BE%E5%8F%AF%E4%BB%A5%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95">4.2. 枚举可以添加方法</a></li>
<li><a href="#43-%E6%9E%9A%E4%B8%BE%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">4.3. 枚举可以实现接口</a></li>
<li><a href="#44-%E6%9E%9A%E4%B8%BE%E4%B8%8D%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF">4.4. 枚举不可以继承</a></li>
</ul>
</li>
<li><a href="#5-%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%BA%94%E7%94%A8">5. 枚举的应用</a><ul>
<li><a href="#51-%E7%BB%84%E7%BB%87%E5%B8%B8%E9%87%8F">5.1. 组织常量</a></li>
<li><a href="#52-switch-%E7%8A%B6%E6%80%81%E6%9C%BA">5.2. switch 状态机</a></li>
<li><a href="#53-%E9%94%99%E8%AF%AF%E7%A0%81">5.3. 错误码</a></li>
<li><a href="#54-%E7%BB%84%E7%BB%87%E6%9E%9A%E4%B8%BE">5.4. 组织枚举</a></li>
<li><a href="#55-%E7%AD%96%E7%95%A5%E6%9E%9A%E4%B8%BE">5.5. 策略枚举</a></li>
<li><a href="#56-%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">5.6. 枚举实现单例模式</a></li>
</ul>
</li>
<li><a href="#6-%E6%9E%9A%E4%B8%BE%E5%B7%A5%E5%85%B7%E7%B1%BB">6. 枚举工具类</a><ul>
<li><a href="#61-enumset">6.1. EnumSet</a></li>
<li><a href="#62-enummap">6.2. EnumMap</a></li>
</ul>
</li>
<li><a href="#7-%E5%B0%8F%E7%BB%93">7. 小结</a></li>
<li><a href="#8-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">8. 参考资料</a></li>
</ul>
<!-- /TOC -->

<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p><code>enum</code> 的全称为 enumeration， 是 JDK5 中引入的特性。</p>
<p>在 Java 中，被 <code>enum</code> 关键字修饰的类型就是枚举类型。形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ColorEn</span> </span>&#123; RED, GREEN, BLUE &#125;</span><br></pre></td></tr></table></figure>

<p><strong>枚举的好处</strong>：可以将常量组织起来，统一进行管理。</p>
<p><strong>枚举的典型应用场景</strong>：错误码、状态机等。</p>
<h2 id="2-枚举的本质"><a href="#2-枚举的本质" class="headerlink" title="2. 枚举的本质"></a>2. 枚举的本质</h2><p><code>java.lang.Enum</code>类声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>新建一个 ColorEn.java 文件，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.dunwu.javacore.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ColorEn</span> </span>&#123;</span><br><span class="line">    RED,YELLOW,BLUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>javac ColorEn.java</code> 命令，生成 ColorEn.class 文件。</p>
<p>然后执行 <code>javap ColorEn.class</code> 命令，输出如下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;ColorEn.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">io</span>.<span class="title">github</span>.<span class="title">dunwu</span>.<span class="title">javacore</span>.<span class="title">enumeration</span>.<span class="title">ColorEn</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">io</span>.<span class="title">github</span>.<span class="title">dunwu</span>.<span class="title">javacore</span>.<span class="title">enumeration</span>.<span class="title">ColorEn</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> io.github.dunwu.javacore.enumeration.ColorEn RED;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> io.github.dunwu.javacore.enumeration.ColorEn YELLOW;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> io.github.dunwu.javacore.enumeration.ColorEn BLUE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> io.github.dunwu.javacore.enumeration.ColorEn[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> io.github.dunwu.javacore.enumeration.<span class="function">ColorEn <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 说明：</p>
<p>从上面的例子可以看出：</p>
<p><strong>枚举的本质是 <code>java.lang.Enum</code> 的子类。</strong></p>
<p>尽管 <code>enum</code> 看起来像是一种新的数据类型，事实上，<strong>enum 是一种受限制的类，并且具有自己的方法</strong>。枚举这种特殊的类因为被修饰为 <code>final</code>，所以不能继承其他类。</p>
<p>定义的枚举值，会被默认修饰为 <code>public static final</code> ，从修饰关键字，即可看出枚举值本质上是静态常量。</p>
</blockquote>
<h2 id="3-枚举的方法"><a href="#3-枚举的方法" class="headerlink" title="3. 枚举的方法"></a>3. 枚举的方法</h2><p>在 enum 中，提供了一些基本方法：</p>
<ul>
<li><code>values()</code>：返回 enum 实例的数组，而且该数组中的元素严格保持在 enum 中声明时的顺序。</li>
<li><code>name()</code>：返回实例名。</li>
<li><code>ordinal()</code>：返回实例声明时的次序，从 0 开始。</li>
<li><code>getDeclaringClass()</code>：返回实例所属的 enum 类型。</li>
<li><code>equals()</code> ：判断是否为同一个对象。</li>
</ul>
<p>可以使用 <code>==</code> 来比较 <code>enum</code>实例。</p>
<p>此外，<code>java.lang.Enum</code>实现了 <code>Comparable</code>和 <code>Serializable</code> 接口，所以也提供 <code>compareTo()</code> 方法。</p>
<p><strong>例：展示 enum 的基本方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;RED, GREEN, BLUE;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Size</span> </span>&#123;BIG, MIDDLE, SMALL;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========== Print all Color ===========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Color c : Color.values()) &#123;</span><br><span class="line">            System.out.println(c + <span class="string">&quot; ordinal: &quot;</span> + c.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========== Print all Size ===========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Size s : Size.values()) &#123;</span><br><span class="line">            System.out.println(s + <span class="string">&quot; ordinal: &quot;</span> + s.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Color green = Color.GREEN;</span><br><span class="line">        System.out.println(<span class="string">&quot;green name(): &quot;</span> + green.name());</span><br><span class="line">        System.out.println(<span class="string">&quot;green getDeclaringClass(): &quot;</span> + green.getDeclaringClass());</span><br><span class="line">        System.out.println(<span class="string">&quot;green hashCode(): &quot;</span> + green.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;green compareTo Color.GREEN: &quot;</span> + green.compareTo(Color.GREEN));</span><br><span class="line">        System.out.println(<span class="string">&quot;green equals Color.GREEN: &quot;</span> + green.equals(Color.GREEN));</span><br><span class="line">        System.out.println(<span class="string">&quot;green equals Size.MIDDLE: &quot;</span> + green.equals(Size.MIDDLE));</span><br><span class="line">        System.out.println(<span class="string">&quot;green equals 1: &quot;</span> + green.equals(<span class="number">1</span>));</span><br><span class="line">        System.out.format(<span class="string">&quot;green == Color.BLUE: %b\n&quot;</span>, green == Color.BLUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=========== Print all Color ===========</span><br><span class="line">RED ordinal: 0</span><br><span class="line">GREEN ordinal: 1</span><br><span class="line">BLUE ordinal: 2</span><br><span class="line">=========== Print all Size ===========</span><br><span class="line">BIG ordinal: 0</span><br><span class="line">MIDDLE ordinal: 1</span><br><span class="line">SMALL ordinal: 2</span><br><span class="line">green name(): GREEN</span><br><span class="line">green getDeclaringClass(): class org.zp.javase.enumeration.EnumDemo$Color</span><br><span class="line">green hashCode(): 460141958</span><br><span class="line">green compareTo Color.GREEN: 0</span><br><span class="line">green equals Color.GREEN: true</span><br><span class="line">green equals Size.MIDDLE: false</span><br><span class="line">green equals 1: false</span><br><span class="line">green == Color.BLUE: false</span><br></pre></td></tr></table></figure>

<h2 id="4-枚举的特性"><a href="#4-枚举的特性" class="headerlink" title="4. 枚举的特性"></a>4. 枚举的特性</h2><p>枚举的特性，归结起来就是一句话：</p>
<blockquote>
<p><strong>除了不能继承，基本上可以将 <code>enum</code> 看做一个常规的类</strong>。</p>
</blockquote>
<p>但是这句话需要拆分去理解，让我们细细道来。</p>
<h3 id="4-1-基本特性"><a href="#4-1-基本特性" class="headerlink" title="4.1. 基本特性"></a>4.1. 基本特性</h3><p><strong>如果枚举中没有定义方法，也可以在最后一个实例后面加逗号、分号或什么都不加。</strong></p>
<p>如果枚举中没有定义方法，<strong>枚举值默认为从 0 开始的有序数值</strong>。以 Color 枚举类型举例，它的枚举常量依次为 <code>RED：0，GREEN：1，BLUE：2</code>。</p>
<h3 id="4-2-枚举可以添加方法"><a href="#4-2-枚举可以添加方法" class="headerlink" title="4.2. 枚举可以添加方法"></a>4.2. 枚举可以添加方法</h3><p>在概念章节提到了，<strong>枚举值默认为从 0 开始的有序数值</strong> 。那么问题来了：如何为枚举显式的赋值。</p>
<p>（1）<strong>Java 不允许使用 <code>=</code> 为枚举常量赋值</strong></p>
<p>如果你接触过 C/C++，你肯定会很自然的想到赋值符号 <code>=</code> 。在 C/C++语言中的 enum，可以用赋值符号 <code>=</code>显式的为枚举常量赋值；但是 ，很遗憾，<strong>Java 语法中却不允许使用赋值符号 <code>=</code> 为枚举常量赋值</strong>。</p>
<p><strong>例：C/C++ 语言中的枚举声明</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ONE = <span class="number">1</span>,</span><br><span class="line">    TWO,</span><br><span class="line">    THREE = <span class="number">3</span>,</span><br><span class="line">    TEN = <span class="number">10</span></span><br><span class="line">&#125; Number;</span><br></pre></td></tr></table></figure>

<p>（2）<strong>枚举可以添加普通方法、静态方法、抽象方法、构造方法</strong></p>
<p>Java 虽然不能直接为实例赋值，但是它有更优秀的解决方案：<strong>为 enum 添加方法来间接实现显式赋值</strong>。</p>
<p>创建 <code>enum</code> 时，可以为其添加多种方法，甚至可以为其添加构造方法。</p>
<p><strong>注意一个细节：如果要为 enum 定义方法，那么必须在 enum 的最后一个实例尾部添加一个分号。此外，在 enum 中，必须先定义实例，不能将字段或方法定义在实例前面。否则，编译器会报错。</strong></p>
<p><strong>例：全面展示如何在枚举中定义普通方法、静态方法、抽象方法、构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ErrorCodeEn</span> </span>&#123;</span><br><span class="line">    OK(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;成功&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ERROR_A(<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;错误A&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ERROR_B(<span class="number">200</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;错误B&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法：enum的构造方法只能被声明为private权限或不声明权限</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ErrorCodeEn</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123; <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.code = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123; <span class="comment">// 普通方法</span></span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125; <span class="comment">// 普通方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; <span class="comment">// 静态方法</span></span><br><span class="line">        <span class="keyword">for</span> (ErrorCodeEn s : ErrorCodeEn.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;code: &quot;</span> + s.getCode() + <span class="string">&quot;, description: &quot;</span> + s.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// code: 0, description: 成功</span></span><br><span class="line"><span class="comment">// code: 100, description: 错误A</span></span><br><span class="line"><span class="comment">// code: 200, description: 错误B</span></span><br></pre></td></tr></table></figure>

<p>注：上面的例子并不可取，仅仅是为了展示枚举支持定义各种方法。正确的例子情况<a href="#%E9%94%99%E8%AF%AF%E7%A0%81">错误码示例</a></p>
<h3 id="4-3-枚举可以实现接口"><a href="#4-3-枚举可以实现接口" class="headerlink" title="4.3. 枚举可以实现接口"></a>4.3. 枚举可以实现接口</h3><p><strong><code>enum</code> 可以像一般类一样实现接口。</strong></p>
<p>同样是实现上一节中的错误码枚举类，通过实现接口，可以约束它的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ErrorCodeEn2</span> <span class="keyword">implements</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">    OK(<span class="number">0</span>, <span class="string">&quot;成功&quot;</span>),</span><br><span class="line">    ERROR_A(<span class="number">100</span>, <span class="string">&quot;错误A&quot;</span>),</span><br><span class="line">    ERROR_B(<span class="number">200</span>, <span class="string">&quot;错误B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ErrorCodeEn2(<span class="keyword">int</span> number, String description) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = number;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-枚举不可以继承"><a href="#4-4-枚举不可以继承" class="headerlink" title="4.4. 枚举不可以继承"></a>4.4. 枚举不可以继承</h3><p><strong>enum 不可以继承另外一个类，当然，也不能继承另一个 enum 。</strong></p>
<p>因为 <code>enum</code> 实际上都继承自 <code>java.lang.Enum</code> 类，而 Java 不支持多重继承，所以 <code>enum</code> 不能再继承其他类，当然也不能继承另一个 <code>enum</code>。</p>
<h2 id="5-枚举的应用"><a href="#5-枚举的应用" class="headerlink" title="5. 枚举的应用"></a>5. 枚举的应用</h2><h3 id="5-1-组织常量"><a href="#5-1-组织常量" class="headerlink" title="5.1. 组织常量"></a>5.1. 组织常量</h3><p>在 JDK5 之前，在 Java 中定义常量都是 <code>public static final TYPE a;</code> 这样的形式。有了枚举，你可以将有关联关系的常量组织起来，使代码更加易读、安全，并且还可以使用枚举提供的方法。</p>
<p>下面三种声明方式是等价的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123; RED, GREEN, BLUE &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123; RED, GREEN, BLUE, &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123; RED, GREEN, BLUE; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-switch-状态机"><a href="#5-2-switch-状态机" class="headerlink" title="5.2. switch 状态机"></a>5.2. switch 状态机</h3><p>我们经常使用 switch 语句来写状态机。JDK7 以后，switch 已经支持 <code>int</code>、<code>char</code>、<code>String</code>、<code>enum</code> 类型的参数。这几种类型的参数比较起来，使用枚举的 switch 代码更具有可读性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachineDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Signal</span> </span>&#123;</span><br><span class="line">        GREEN, YELLOW, RED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getTrafficInstruct</span><span class="params">(Signal signal)</span> </span>&#123;</span><br><span class="line">        String instruct = <span class="string">&quot;信号灯故障&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (signal) &#123;</span><br><span class="line">            <span class="keyword">case</span> RED:</span><br><span class="line">                instruct = <span class="string">&quot;红灯停&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YELLOW:</span><br><span class="line">                instruct = <span class="string">&quot;黄灯请注意&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GREEN:</span><br><span class="line">                instruct = <span class="string">&quot;绿灯行&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instruct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getTrafficInstruct(Signal.RED));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 红灯停</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-错误码"><a href="#5-3-错误码" class="headerlink" title="5.3. 错误码"></a>5.3. 错误码</h3><p>枚举常被用于定义程序错误码。下面是一个简单示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorCodeEnumDemo</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ErrorCodeEn</span> </span>&#123;</span><br><span class="line">        OK(<span class="number">0</span>, <span class="string">&quot;成功&quot;</span>),</span><br><span class="line">        ERROR_A(<span class="number">100</span>, <span class="string">&quot;错误A&quot;</span>),</span><br><span class="line">        ERROR_B(<span class="number">200</span>, <span class="string">&quot;错误B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ErrorCodeEn(<span class="keyword">int</span> number, String msg) &#123;</span><br><span class="line">            <span class="keyword">this</span>.code = number;</span><br><span class="line">            <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">        <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> code;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;ErrorCodeEn&#123;&quot;</span> + <span class="string">&quot;code=&quot;</span> + code + <span class="string">&quot;, msg=&#x27;&quot;</span> + msg + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toStringAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(<span class="string">&quot;ErrorCodeEn All Elements: [&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (ErrorCodeEn code : ErrorCodeEn.values()) &#123;</span><br><span class="line">                sb.append(code.getCode()).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ErrorCodeEn.toStringAll());</span><br><span class="line">        <span class="keyword">for</span> (ErrorCodeEn s : ErrorCodeEn.values()) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// ErrorCodeEn All Elements: [0, 100, 200, ]</span></span><br><span class="line"><span class="comment">// ErrorCodeEn&#123;code=0, msg=&#x27;成功&#x27;&#125;</span></span><br><span class="line"><span class="comment">// ErrorCodeEn&#123;code=100, msg=&#x27;错误A&#x27;&#125;</span></span><br><span class="line"><span class="comment">// ErrorCodeEn&#123;code=200, msg=&#x27;错误B&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4-组织枚举"><a href="#5-4-组织枚举" class="headerlink" title="5.4. 组织枚举"></a>5.4. 组织枚举</h3><p>可以将类型相近的枚举通过接口或类组织起来，但是一般用接口方式进行组织。</p>
<p>原因是：Java 接口在编译时会自动为 enum 类型加上 <code>public static</code>修饰符；Java 类在编译时会自动为 <code>enum</code> 类型加上 static 修饰符。看出差异了吗？没错，就是说，在类中组织 <code>enum</code>，如果你不给它修饰为 <code>public</code>，那么只能在本包中进行访问。</p>
<p><strong>例：在接口中组织 enum</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumInInterfaceDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Plant</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">Vegetable</span> <span class="keyword">implements</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">            POTATO(<span class="number">0</span>, <span class="string">&quot;土豆&quot;</span>),</span><br><span class="line">            TOMATO(<span class="number">0</span>, <span class="string">&quot;西红柿&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Vegetable(<span class="keyword">int</span> number, String description) &#123;</span><br><span class="line">                <span class="keyword">this</span>.code = number;</span><br><span class="line">                <span class="keyword">this</span>.description = description;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">            <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.code;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.description;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">Fruit</span> <span class="keyword">implements</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">            APPLE(<span class="number">0</span>, <span class="string">&quot;苹果&quot;</span>),</span><br><span class="line">            ORANGE(<span class="number">0</span>, <span class="string">&quot;桔子&quot;</span>),</span><br><span class="line">            BANANA(<span class="number">0</span>, <span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Fruit(<span class="keyword">int</span> number, String description) &#123;</span><br><span class="line">                <span class="keyword">this</span>.code = number;</span><br><span class="line">                <span class="keyword">this</span>.description = description;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">            <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.code;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.description;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Plant.Fruit f : Plant.Fruit.values()) &#123;</span><br><span class="line">            System.out.println(f.getDescription());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 苹果</span></span><br><span class="line"><span class="comment">// 桔子</span></span><br><span class="line"><span class="comment">// 香蕉</span></span><br></pre></td></tr></table></figure>

<p><strong>例：在类中组织 enum</strong></p>
<p>本例和上例效果相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumInClassDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Plant2</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">Vegetable</span> <span class="keyword">implements</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 略，与上面完全相同</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">Fruit</span> <span class="keyword">implements</span> <span class="title">INumberEnum</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 略，与上面完全相同</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 土豆</span></span><br><span class="line"><span class="comment">// 西红柿</span></span><br></pre></td></tr></table></figure>

<h3 id="5-5-策略枚举"><a href="#5-5-策略枚举" class="headerlink" title="5.5. 策略枚举"></a>5.5. 策略枚举</h3><p>Effective Java 中展示了一种策略枚举。这种枚举通过枚举嵌套枚举的方式，将枚举常量分类处理。</p>
<p>这种做法虽然没有 switch 语句简洁，但是更加安全、灵活。</p>
<p><strong>例：EffectvieJava 中的策略枚举范例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PayrollDay</span> </span>&#123;</span><br><span class="line">    MONDAY(PayType.WEEKDAY), TUESDAY(PayType.WEEKDAY), WEDNESDAY(</span><br><span class="line">            PayType.WEEKDAY), THURSDAY(PayType.WEEKDAY), FRIDAY(PayType.WEEKDAY), SATURDAY(</span><br><span class="line">            PayType.WEEKEND), SUNDAY(PayType.WEEKEND);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayType payType;</span><br><span class="line"></span><br><span class="line">    PayrollDay(PayType payType) &#123;</span><br><span class="line">        <span class="keyword">this</span>.payType = payType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">pay</span><span class="params">(<span class="keyword">double</span> hoursWorked, <span class="keyword">double</span> payRate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> payType.pay(hoursWorked, payRate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略枚举</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">PayType</span> </span>&#123;</span><br><span class="line">        WEEKDAY &#123;</span><br><span class="line">            <span class="function"><span class="keyword">double</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">double</span> hours, <span class="keyword">double</span> payRate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> hours &lt;= HOURS_PER_SHIFT ? <span class="number">0</span> : (hours - HOURS_PER_SHIFT)</span><br><span class="line">                        * payRate / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        WEEKEND &#123;</span><br><span class="line">            <span class="function"><span class="keyword">double</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">double</span> hours, <span class="keyword">double</span> payRate)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> hours * payRate / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOURS_PER_SHIFT = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">overtimePay</span><span class="params">(<span class="keyword">double</span> hrs, <span class="keyword">double</span> payRate)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">pay</span><span class="params">(<span class="keyword">double</span> hoursWorked, <span class="keyword">double</span> payRate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">double</span> basePay = hoursWorked * payRate;</span><br><span class="line">            <span class="keyword">return</span> basePay + overtimePay(hoursWorked, payRate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;时薪100的人在周五工作8小时的收入：&quot;</span> + PayrollDay.FRIDAY.pay(<span class="number">8.0</span>, <span class="number">100</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;时薪100的人在周六工作8小时的收入：&quot;</span> + PayrollDay.SATURDAY.pay(<span class="number">8.0</span>, <span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<h3 id="5-6-枚举实现单例模式"><a href="#5-6-枚举实现单例模式" class="headerlink" title="5.6. 枚举实现单例模式"></a>5.6. 枚举实现单例模式</h3><p>单例模式是最常用的设计模式。</p>
<p>单例模式在并发环境下存在线程安全问题。</p>
<p>为了线程安全问题，传统做法有以下几种：</p>
<ul>
<li>饿汉式加载</li>
<li>懒汉式 synchronize 和双重检查</li>
<li>利用 java 的静态加载机制</li>
</ul>
<p>相比上述的方法，使用枚举也可以实现单例，而且还更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleEnumDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingleEn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingleEn.INSTANCE.setName(<span class="string">&quot;zp&quot;</span>);</span><br><span class="line">        System.out.println(SingleEn.INSTANCE.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展阅读：<a href="https://blog.csdn.net/javazejian/article/details/71333103#enumset%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90">深入理解 Java 枚举类型(enum)</a></p>
<p>这篇文章对于 Java 枚举的特性讲解很仔细，其中对于枚举实现单例和传统单例实现方式说的尤为细致。</p>
</blockquote>
<h2 id="6-枚举工具类"><a href="#6-枚举工具类" class="headerlink" title="6. 枚举工具类"></a>6. 枚举工具类</h2><p>Java 中提供了两个方便操作 enum 的工具类——<code>EnumSet</code> 和 <code>EnumMap</code>。</p>
<h3 id="6-1-EnumSet"><a href="#6-1-EnumSet" class="headerlink" title="6.1. EnumSet"></a>6.1. EnumSet</h3><p><code>EnumSet</code> 是枚举类型的高性能 <code>Set</code> 实现。它要求放入它的枚举常量必须属于同一枚举类型。</p>
<p>主要接口：</p>
<ul>
<li><code>noneOf</code> - 创建一个具有指定元素类型的空 EnumSet</li>
<li><code>allOf</code> - 创建一个指定元素类型并包含所有枚举值的 EnumSet</li>
<li><code>range</code> - 创建一个包括枚举值中指定范围元素的 EnumSet</li>
<li><code>complementOf</code> - 初始集合包括指定集合的补集</li>
<li><code>of</code> - 创建一个包括参数中所有元素的 EnumSet</li>
<li><code>copyOf</code> - 创建一个包含参数容器中的所有元素的 EnumSet</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;EnumSet展示&quot;</span>);</span><br><span class="line">        EnumSet&lt;ErrorCodeEn&gt; errSet = EnumSet.allOf(ErrorCodeEn.class);</span><br><span class="line">        <span class="keyword">for</span> (ErrorCodeEn e : errSet) &#123;</span><br><span class="line">            System.out.println(e.name() + <span class="string">&quot; : &quot;</span> + e.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-EnumMap"><a href="#6-2-EnumMap" class="headerlink" title="6.2. EnumMap"></a>6.2. EnumMap</h3><p><code>EnumMap</code> 是专门为枚举类型量身定做的 <code>Map</code> 实现。虽然使用其它的 Map 实现（如 HashMap）也能完成枚举类型实例到值得映射，但是使用 EnumMap 会更加高效：它只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 EnumMap 使用数组来存放与枚举类型对应的值。这使得 EnumMap 的效率非常高。</p>
<p>主要接口：</p>
<ul>
<li><code>size</code> - 返回键值对数</li>
<li><code>containsValue</code> - 是否存在指定的 value</li>
<li><code>containsKey</code> - 是否存在指定的 key</li>
<li><code>get</code> - 根据指定 key 获取 value</li>
<li><code>put</code> - 取出指定的键值对</li>
<li><code>remove</code> - 删除指定 key</li>
<li><code>putAll</code> - 批量取出键值对</li>
<li><code>clear</code> - 清除数据</li>
<li><code>keySet</code> - 获取 key 集合</li>
<li><code>values</code> - 返回所有</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Signal</span> </span>&#123;</span><br><span class="line">        GREEN, YELLOW, RED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;EnumMap展示&quot;</span>);</span><br><span class="line">        EnumMap&lt;Signal, String&gt; errMap = <span class="keyword">new</span> EnumMap(Signal.class);</span><br><span class="line">        errMap.put(Signal.RED, <span class="string">&quot;红灯&quot;</span>);</span><br><span class="line">        errMap.put(Signal.YELLOW, <span class="string">&quot;黄灯&quot;</span>);</span><br><span class="line">        errMap.put(Signal.GREEN, <span class="string">&quot;绿灯&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Signal, String&gt;&gt; iter = errMap.entrySet().iterator(); iter.hasNext();) &#123;</span><br><span class="line">            Map.Entry&lt;Signal, String&gt; entry = iter.next();</span><br><span class="line">            System.out.println(entry.getKey().name() + <span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展阅读：<a href="https://blog.csdn.net/javazejian/article/details/71333103#enumset%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90">深入理解 Java 枚举类型(enum)</a></p>
<p>这篇文章中对 EnumSet 和 EnumMap 原理做了较为详细的介绍。</p>
</blockquote>
<h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1553002212154.png" alt="img"></p>
<h2 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8. 参考资料"></a>8. 参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
<li><a href="https://book.douban.com/subject/3360807/">Effective java</a></li>
<li><a href="https://blog.csdn.net/javazejian/article/details/71333103#enumset%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90">深入理解 Java 枚举类型(enum)</a></li>
<li><a href="https://droidyue.com/blog/2016/11/29/dive-into-enum/">https://droidyue.com/blog/2016/11/29/dive-into-enum/</a></li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>枚举类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 开发环境</title>
    <url>/2021/12/06/java-develop-env/</url>
    <content><![CDATA[<h1 id="Java-开发环境"><a href="#Java-开发环境" class="headerlink" title="Java 开发环境"></a>Java 开发环境</h1><blockquote>
<p>📌 <strong>关键词：</strong> JAVA_HOME、CLASSPATH、Path、环境变量、IDE</p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->

<ul>
<li><a href="#1-%E4%B8%8B%E8%BD%BD">1. 下载</a></li>
<li><a href="#2-%E5%AE%89%E8%A3%85">2. 安装</a></li>
<li><a href="#3-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">3. 环境变量</a><ul>
<li><a href="#31-windows">3.1. Windows</a></li>
<li><a href="#32-linux">3.2. Linux</a></li>
</ul>
</li>
<li><a href="#4-%E6%B5%8B%E8%AF%95%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F">4. 测试安装成功</a></li>
<li><a href="#5-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7">5. 开发工具</a></li>
<li><a href="#6-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8Fhello-world">6. 第一个程序：Hello World</a></li>
</ul>
<!-- /TOC -->

<h2 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h2><p>进入 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">JDK 官方下载地址</a> ，根据自己的环境选择下载所需版本。</p>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><p>windows 环境的 jdk 包是 exe 安装文件，启动后根据安装向导安装即可。</p>
<p>Linux 环境的 jdk 包，解压到本地即可。</p>
<h2 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="3. 环境变量"></a>3. 环境变量</h2><h3 id="3-1-Windows"><a href="#3-1-Windows" class="headerlink" title="3.1. Windows"></a>3.1. Windows</h3><p>计算机 &gt; 属性 &gt; 高级系统设置 &gt; 环境变量</p>
<p>添加以下环境变量：</p>
<p><code>JAVA_HOME</code>：<code>C:\Program Files (x86)\Java\jdk1.8.0_91</code> （根据自己的实际路径配置）</p>
<p><code>CLASSPATH</code>：<code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code> （注意前面有个”.”）</p>
<p><code>Path</code>：<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code></p>
<h3 id="3-2-Linux"><a href="#3-2-Linux" class="headerlink" title="3.2. Linux"></a>3.2. Linux</h3><p>执行 <code>vi /etc/profile</code> ，编辑环境变量文件</p>
<p>添加两行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=path/to/java</span><br><span class="line">export PATH=JAVA_HOME/bin:JAVA_HOME/jre/bin:</span><br></pre></td></tr></table></figure>

<p>执行 <code>source /etc/profile</code> ，立即生效。</p>
<h2 id="4-测试安装成功"><a href="#4-测试安装成功" class="headerlink" title="4. 测试安装成功"></a>4. 测试安装成功</h2><p>执行命令 <code>java -version</code> ，如果安装成功，会打印当前 java 的版本信息。</p>
<h2 id="5-开发工具"><a href="#5-开发工具" class="headerlink" title="5. 开发工具"></a>5. 开发工具</h2><p>工欲善其事，必先利其器。编写 Java 程序，当然有必要选择一个合适的 IDE。</p>
<p>IDE（Integrated Development Environment，即集成开发环境）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。</p>
<p>常见的 Java IDE 如下：</p>
<ul>
<li>Eclipse - 一个开放源代码的、基于 Java 的可扩展开发平台。</li>
<li>NetBeans - 开放源码的 Java 集成开发环境，适用于各种客户机和 Web 应用。</li>
<li>IntelliJ IDEA - 在代码自动提示、代码分析等方面的具有很好的功能。</li>
<li>MyEclipse - 由 Genuitec 公司开发的一款商业化软件，是应用比较广泛的 Java 应用程序集成开发环境。</li>
<li>EditPlus - 如果正确配置 Java 的编译器“Javac”以及解释器“Java”后，可直接使用 EditPlus 编译执行 Java 程序。</li>
</ul>
<h2 id="6-第一个程序：Hello-World"><a href="#6-第一个程序：Hello-World" class="headerlink" title="6. 第一个程序：Hello World"></a>6. 第一个程序：Hello World</h2><p>添加 HelloWorld.java 文件，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后，控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 控制语句</title>
    <url>/2021/12/06/java-control-statement/</url>
    <content><![CDATA[<h1 id="Java-控制语句"><a href="#Java-控制语句" class="headerlink" title="Java 控制语句"></a>Java 控制语句</h1><blockquote>
<p><strong>📦 本文以及示例源码已归档在 <a href="https://github.com/dunwu/javacore/">javacore</a></strong></p>
<p>Java 控制语句大致可分为三大类：</p>
<ul>
<li>选择语句<ul>
<li>if, else-if, else</li>
<li>switch</li>
</ul>
</li>
<li>循环语句<ul>
<li>while</li>
<li>do…while</li>
<li>for</li>
<li>foreach</li>
</ul>
</li>
<li>终端语句<ul>
<li>break</li>
<li>continue</li>
<li>return</li>
</ul>
</li>
</ul>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->

<ul>
<li><a href="#1-%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5">1. 选择语句</a><ul>
<li><a href="#11-if-%E8%AF%AD%E5%8F%A5">1.1. if 语句</a></li>
<li><a href="#12-ifelse-%E8%AF%AD%E5%8F%A5">1.2. if…else 语句</a></li>
<li><a href="#13-ifelse-ifelse-%E8%AF%AD%E5%8F%A5">1.3. if…else if…else 语句</a></li>
<li><a href="#14-%E5%B5%8C%E5%A5%97%E7%9A%84-ifelse-%E8%AF%AD%E5%8F%A5">1.4. 嵌套的 if…else 语句</a></li>
<li><a href="#15-switch-%E8%AF%AD%E5%8F%A5">1.5. switch 语句</a></li>
</ul>
</li>
<li><a href="#2-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">2. 循环语句</a><ul>
<li><a href="#21-while-%E5%BE%AA%E7%8E%AF">2.1. while 循环</a></li>
<li><a href="#22-do-while-%E5%BE%AA%E7%8E%AF">2.2. do while 循环</a></li>
<li><a href="#23-for-%E5%BE%AA%E7%8E%AF">2.3. for 循环</a></li>
<li><a href="#24-foreach-%E5%BE%AA%E7%8E%AF">2.4. foreach 循环</a></li>
</ul>
</li>
<li><a href="#3-%E4%B8%AD%E6%96%AD%E8%AF%AD%E5%8F%A5">3. 中断语句</a><ul>
<li><a href="#31-break-%E5%85%B3%E9%94%AE%E5%AD%97">3.1. break 关键字</a></li>
<li><a href="#32-continue-%E5%85%B3%E9%94%AE%E5%AD%97">3.2. continue 关键字</a></li>
<li><a href="#33-return-%E5%85%B3%E9%94%AE%E5%AD%97">3.3. return 关键字</a></li>
</ul>
</li>
<li><a href="#4-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">4. 最佳实践</a></li>
<li><a href="#5-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">5. 参考资料</a></li>
</ul>
<!-- /TOC -->

<h2 id="1-选择语句"><a href="#1-选择语句" class="headerlink" title="1. 选择语句"></a>1. 选择语句</h2><h3 id="1-1-if-语句"><a href="#1-1-if-语句" class="headerlink" title="1.1. if 语句"></a>1.1. if 语句</h3><p><code>if</code> 语句会判断括号中的条件是否成立，如果成立则执行 <code>if</code> 语句中的代码块，否则跳过代码块继续执行。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式) &#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式为true将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;这是 if 语句&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 这是 if 语句</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-if…else-语句"><a href="#1-2-if…else-语句" class="headerlink" title="1.2. if…else 语句"></a>1.2. if…else 语句</h3><p><code>if</code> 语句后面可以跟 <code>else</code> 语句，当 <code>if</code> 语句的布尔表达式值为 <code>false</code> 时，<code>else</code> 语句块会被执行。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式) &#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式的值为true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式的值为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfElseDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;这是 if 语句&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;这是 else 语句&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 这是 else 语句</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-if…else-if…else-语句"><a href="#1-3-if…else-if…else-语句" class="headerlink" title="1.3. if…else if…else 语句"></a>1.3. if…else if…else 语句</h3><ul>
<li><code>if</code> 语句至多有 1 个 <code>else</code> 语句，<code>else</code> 语句在所有的 <code>else if</code> 语句之后。</li>
<li><code>If</code> 语句可以有若干个 <code>else if</code> 语句，它们必须在 <code>else</code> 语句之前。</li>
<li>一旦其中一个 <code>else if</code> 语句检测为 <code>true</code>，其他的 <code>else if</code> 以及 <code>else</code> 语句都将跳过执行。</li>
</ul>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔表达式 <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式 1的值为true执行代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (布尔表达式 <span class="number">2</span>) &#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式 2的值为true执行代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (布尔表达式 <span class="number">3</span>) &#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式 3的值为true执行代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//如果以上布尔表达式都不为true执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfElseifElseDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;Value of X is 1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;Value of X is 2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;Value of X is 3&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;This is else statement&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Value of X is 3</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-嵌套的-if…else-语句"><a href="#1-4-嵌套的-if…else-语句" class="headerlink" title="1.4. 嵌套的 if…else 语句"></a>1.4. 嵌套的 if…else 语句</h3><p>使用嵌套的 <code>if else</code> 语句是合法的。也就是说你可以在另一个 <code>if</code> 或者 <code>else if</code> 语句中使用 <code>if</code> 或者 <code>else if</code> 语句。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔表达式 <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="comment">////如果布尔表达式 1的值为true执行代码</span></span><br><span class="line">   <span class="keyword">if</span> (布尔表达式 <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">////如果布尔表达式 2的值为true执行代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfNestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">30</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y == <span class="number">10</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;X = 30 and Y = 10&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// X = 30 and Y = 10</span></span><br></pre></td></tr></table></figure>

<h3 id="1-5-switch-语句"><a href="#1-5-switch-语句" class="headerlink" title="1.5. switch 语句"></a>1.5. switch 语句</h3><p><code>switch</code> 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>
<p><code>switch</code> 语句有如下规则：</p>
<ul>
<li><code>switch</code> 语句中的变量类型只能为 <code>byte</code>、<code>short</code>、<code>int</code>、<code>char</code> 或者 <code>String</code>。</li>
<li><code>switch</code> 语句可以拥有多个 <code>case</code> 语句。每个 <code>case</code> 后面跟一个要比较的值和冒号。</li>
<li><code>case</code> 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li>
<li>当变量的值与 <code>case</code> 语句的值相等时，那么 <code>case</code> 语句之后的语句开始执行，直到 <code>break</code> 语句出现才会跳出 <code>switch</code> 语句。</li>
<li>当遇到 <code>break</code> 语句时，<code>switch</code> 语句终止。程序跳转到 <code>switch</code> 语句后面的语句执行。<code>case</code> 语句不必须要包含 <code>break</code> 语句。如果没有 <code>break</code> 语句出现，程序会继续执行下一条 <code>case</code> 语句，直到出现 <code>break</code> 语句。</li>
<li><code>switch</code> 语句可以包含一个 <code>default</code> 分支，该分支必须是 <code>switch</code> 语句的最后一个分支。<code>default</code> 在没有 <code>case</code> 语句的值和变量值相等的时候执行。<code>default</code> 分支不需要 <code>break</code> 语句。</li>
</ul>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选</span></span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选，但一般建议加上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> grade = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Excellent!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Well done&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;You passed&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Better try again&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Invalid grade&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Your grade is &quot;</span> + grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Well done</span></span><br><span class="line"><span class="comment">// Your grade is C</span></span><br></pre></td></tr></table></figure>

<h2 id="2-循环语句"><a href="#2-循环语句" class="headerlink" title="2. 循环语句"></a>2. 循环语句</h2><h3 id="2-1-while-循环"><a href="#2-1-while-循环" class="headerlink" title="2.1. while 循环"></a>2.1. while 循环</h3><p>只要布尔表达式为 <code>true</code>，<code>while</code> 循环体会一直执行下去。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>( 布尔表达式 ) &#123;</span><br><span class="line">    <span class="comment">//循环内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;value of x : &quot;</span> + x);</span><br><span class="line">            x++;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// value of x : 10</span></span><br><span class="line"><span class="comment">// value of x : 11</span></span><br><span class="line"><span class="comment">// value of x : 12</span></span><br><span class="line"><span class="comment">// value of x : 13</span></span><br><span class="line"><span class="comment">// value of x : 14</span></span><br><span class="line"><span class="comment">// value of x : 15</span></span><br><span class="line"><span class="comment">// value of x : 16</span></span><br><span class="line"><span class="comment">// value of x : 17</span></span><br><span class="line"><span class="comment">// value of x : 18</span></span><br><span class="line"><span class="comment">// value of x : 19</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-do-while-循环"><a href="#2-2-do-while-循环" class="headerlink" title="2.2. do while 循环"></a>2.2. do while 循环</h3><p>对于 <code>while</code> 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p>
<p><code>do while</code> 循环和 <code>while</code> 循环相似，不同的是，<code>do while</code> 循环至少会执行一次。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125; <span class="keyword">while</span> (布尔表达式);</span><br></pre></td></tr></table></figure>

<p>布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoWhileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;value of x : &quot;</span> + x);</span><br><span class="line">            x++;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (x &lt; <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// value of x:10</span></span><br><span class="line"><span class="comment">// value of x:11</span></span><br><span class="line"><span class="comment">// value of x:12</span></span><br><span class="line"><span class="comment">// value of x:13</span></span><br><span class="line"><span class="comment">// value of x:14</span></span><br><span class="line"><span class="comment">// value of x:15</span></span><br><span class="line"><span class="comment">// value of x:16</span></span><br><span class="line"><span class="comment">// value of x:17</span></span><br><span class="line"><span class="comment">// value of x:18</span></span><br><span class="line"><span class="comment">// value of x:19</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-for-循环"><a href="#2-3-for-循环" class="headerlink" title="2.3. for 循环"></a>2.3. for 循环</h3><p>虽然所有循环结构都可以用 <code>while</code> 或者 <code>do while</code> 表示，但 Java 提供了另一种语句 —— <code>for</code> 循环，使一些循环结构变得更加简单。<br><code>for</code> 循环执行的次数是在执行前就确定的。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 布尔表达式; 更新) &#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</li>
<li>然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为 false，循环终止，开始执行循环体后面的语句。</li>
<li>执行一次循环后，更新循环控制变量。</li>
<li>再次检测布尔表达式。循环执行上面的过程。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">10</span>; x &lt; <span class="number">20</span>; x = x + <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;value of x : &quot;</span> + x);</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// value of x : 10</span></span><br><span class="line"><span class="comment">// value of x : 11</span></span><br><span class="line"><span class="comment">// value of x : 12</span></span><br><span class="line"><span class="comment">// value of x : 13</span></span><br><span class="line"><span class="comment">// value of x : 14</span></span><br><span class="line"><span class="comment">// value of x : 15</span></span><br><span class="line"><span class="comment">// value of x : 16</span></span><br><span class="line"><span class="comment">// value of x : 17</span></span><br><span class="line"><span class="comment">// value of x : 18</span></span><br><span class="line"><span class="comment">// value of x : 19</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-foreach-循环"><a href="#2-4-foreach-循环" class="headerlink" title="2.4. foreach 循环"></a>2.4. foreach 循环</h3><p>Java5 引入了一种主要用于数组的增强型 for 循环。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (声明语句 : 表达式) &#123;</span><br><span class="line">    <span class="comment">//代码句子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>声明语句</strong>：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p>
<p><strong>表达式</strong>：表达式是要访问的数组名，或者是返回值为数组的方法。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForeachDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : numbers) &#123;</span><br><span class="line">            System.out.print(x);</span><br><span class="line">            System.out.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        String[] names = &#123; <span class="string">&quot;James&quot;</span>, <span class="string">&quot;Larry&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Lacy&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.print(name);</span><br><span class="line">            System.out.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 10,20,30,40,50,</span></span><br><span class="line"><span class="comment">// James,Larry,Tom,Lacy,</span></span><br></pre></td></tr></table></figure>

<h2 id="3-中断语句"><a href="#3-中断语句" class="headerlink" title="3. 中断语句"></a>3. 中断语句</h2><h3 id="3-1-break-关键字"><a href="#3-1-break-关键字" class="headerlink" title="3.1. break 关键字"></a>3.1. break 关键字</h3><p><code>break</code> 主要用在循环语句或者 <code>switch</code> 语句中，用来跳出整个语句块。</p>
<p><code>break</code> 跳出最里层的循环，并且继续执行该循环下面的语句。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreakDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">30</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(x);</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;break 示例结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line"><span class="comment">// break 示例结束</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-continue-关键字"><a href="#3-2-continue-关键字" class="headerlink" title="3.2. continue 关键字"></a>3.2. continue 关键字</h3><p><code>continue</code> 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在 <code>for</code> 循环中，<code>continue</code> 语句使程序立即跳转到更新语句。在 <code>while</code> 或者 <code>do while</code> 循环中，程序立即跳转到布尔表达式的判断语句。</p>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContinueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">30</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(x);</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line"><span class="comment">// 40</span></span><br><span class="line"><span class="comment">// 50</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-return-关键字"><a href="#3-3-return-关键字" class="headerlink" title="3.3. return 关键字"></a>3.3. return 关键字</h3><p>跳出整个函数体，函数体后面的部分不再执行。</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">30</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(x);</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;return 示例结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>🔔 注意：请仔细体会一下 <code>return</code> 和 <code>break</code> 的区别。</p>
</blockquote>
<h2 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4. 最佳实践"></a>4. 最佳实践</h2><ul>
<li>选择分支特别多的情况下，<code>switch</code> 语句优于 <code>if...else if...else</code> 语句。</li>
<li><code>switch</code> 语句不要吝啬使用 <code>default</code>。</li>
<li><code>switch</code> 语句中的 <code>default</code> 要放在最后。</li>
<li><code>foreach</code> 循环优先于传统的 <code>for</code> 循环</li>
<li>不要循环遍历容器元素，然后删除特定元素。正确姿势应该是遍历容器的迭代器（<code>Iterator</code>），删除元素。</li>
</ul>
<h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/06/java-data-type/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title="-"></a>-</h1><hr>
<p>title: 深入理解 Java 基本数据类型<br>author: 唐凯鹏<br>categories: java基础<br>tags:</p>
<ul>
<li></li>
<li>–<h1 id="深入理解-Java-基本数据类型"><a href="#深入理解-Java-基本数据类型" class="headerlink" title="深入理解 Java 基本数据类型"></a>深入理解 Java 基本数据类型</h1></li>
</ul>
<blockquote>
<p><strong>📦 本文以及示例源码已归档在 <a href="https://github.com/dunwu/javacore/">javacore</a></strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1553754196283.png" alt="img"></p>
<!-- TOC depthFrom:2 depthTo:3 -->

<ul>
<li><a href="#1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">1. 数据类型分类</a><ul>
<li><a href="#11-%E5%80%BC%E7%B1%BB%E5%9E%8B">1.1. 值类型</a></li>
<li><a href="#12-%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB">1.2. 值类型和引用类型的区别</a></li>
</ul>
</li>
<li><a href="#2-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2">2. 数据转换</a><ul>
<li><a href="#21-%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2">2.1. 自动转换</a></li>
<li><a href="#22-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2">2.2. 强制转换</a></li>
</ul>
</li>
<li><a href="#3-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1">3. 装箱和拆箱</a><ul>
<li><a href="#31-%E5%8C%85%E8%A3%85%E7%B1%BB%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1">3.1. 包装类、装箱、拆箱</a></li>
<li><a href="#32-%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1">3.2. 自动装箱、自动拆箱</a></li>
<li><a href="#33-%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9">3.3. 装箱、拆箱的应用和注意点</a></li>
</ul>
</li>
<li><a href="#4-%E5%88%A4%E7%AD%89%E9%97%AE%E9%A2%98">4. 判等问题</a><ul>
<li><a href="#41-%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%88%A4%E7%AD%89">4.1. 包装类的判等</a></li>
<li><a href="#42-string-%E7%9A%84%E5%88%A4%E7%AD%89">4.2. String 的判等</a></li>
<li><a href="#43-%E5%AE%9E%E7%8E%B0-equals">4.3. 实现 equals</a></li>
<li><a href="#44-hashcode-%E5%92%8C-equals-%E8%A6%81%E9%85%8D%E5%AF%B9%E5%AE%9E%E7%8E%B0">4.4. hashCode 和 equals 要配对实现</a></li>
<li><a href="#45-compareto-%E5%92%8C-equals-%E7%9A%84%E9%80%BB%E8%BE%91%E4%B8%80%E8%87%B4%E6%80%A7">4.5. compareTo 和 equals 的逻辑一致性</a></li>
<li><a href="#46-%E5%B0%8F%E5%BF%83-lombok-%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9D%91">4.6. 小心 Lombok 生成代码的“坑”</a></li>
</ul>
</li>
<li><a href="#5-%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97">5. 数值计算</a><ul>
<li><a href="#51-%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98">5.1. 浮点数计算问题</a></li>
<li><a href="#52-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96">5.2. 浮点数精度和格式化</a></li>
<li><a href="#53-bigdecimal-%E5%88%A4%E7%AD%89%E9%97%AE%E9%A2%98">5.3. BigDecimal 判等问题</a></li>
<li><a href="#54-%E6%95%B0%E5%80%BC%E6%BA%A2%E5%87%BA">5.4. 数值溢出</a></li>
</ul>
</li>
<li><a href="#6-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">6. 参考资料</a></li>
</ul>
<!-- /TOC -->

<h2 id="1-数据类型分类"><a href="#1-数据类型分类" class="headerlink" title="1. 数据类型分类"></a>1. 数据类型分类</h2><p>Java 中的数据类型有两类：</p>
<ul>
<li>值类型（又叫内置数据类型，基本数据类型）</li>
<li>引用类型（除值类型以外，都是引用类型，包括 <code>String</code>、数组）</li>
</ul>
<h3 id="1-1-值类型"><a href="#1-1-值类型" class="headerlink" title="1.1. 值类型"></a>1.1. 值类型</h3><p>Java 语言提供了 <strong>8</strong> 种基本类型，大致分为 <strong>4</strong> 类</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>分类</th>
<th>比特数</th>
<th>默认值</th>
<th>取值范围</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><strong>布尔型</strong></td>
<td>8 位</td>
<td><code>false</code></td>
<td>{false, true}</td>
<td></td>
</tr>
<tr>
<td><code>char</code></td>
<td><strong>字符型</strong></td>
<td>16 位</td>
<td><code>&#39;\u0000&#39;</code></td>
<td>[0,$2^{16} - 1$]</td>
<td>存储 Unicode 码，用单引号赋值</td>
</tr>
<tr>
<td><code>byte</code></td>
<td><strong>整数型</strong></td>
<td>8 位</td>
<td><code>0</code></td>
<td>[-$2^7$, $2^7 - 1$]</td>
<td></td>
</tr>
<tr>
<td><code>short</code></td>
<td><strong>整数型</strong></td>
<td>16 位</td>
<td><code>0</code></td>
<td>[-$2^{15}$, $2^{15} - 1$]</td>
<td></td>
</tr>
<tr>
<td><code>int</code></td>
<td><strong>整数型</strong></td>
<td>32 位</td>
<td><code>0</code></td>
<td>[-$2^{31}$, $2^{31} - 1$]</td>
<td></td>
</tr>
<tr>
<td><code>long</code></td>
<td><strong>整数型</strong></td>
<td>64 位</td>
<td><code>0L</code></td>
<td>[-$2^{63}$, $2^{63} - 1$]</td>
<td>赋值时一般在数字后加上 <code>l</code> 或 <code>L</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><strong>浮点型</strong></td>
<td>32 位</td>
<td><code>+0.0F</code></td>
<td>[$2^{-149}$, $2^{128} - 1$]</td>
<td>赋值时必须在数字后加上 <code>f</code> 或 <code>F</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><strong>浮点型</strong></td>
<td>64 位</td>
<td><code>+0.0D</code></td>
<td>[$2^{-1074}$, $2^{1024} - 1$]</td>
<td>赋值时一般在数字后加 <code>d</code> 或 <code>D</code></td>
</tr>
</tbody></table>
<p>尽管各种数据类型的默认值看起来不一样，但在内存中都是 0。</p>
<p>在这些基本类型中，<code>boolean</code> 和 <code>char</code> 是唯二的无符号类型。</p>
<h3 id="1-2-值类型和引用类型的区别"><a href="#1-2-值类型和引用类型的区别" class="headerlink" title="1.2. 值类型和引用类型的区别"></a>1.2. 值类型和引用类型的区别</h3><ul>
<li>从概念方面来说<ul>
<li>基本类型：变量名指向具体的数值。</li>
<li>引用类型：变量名指向存数据对象的内存地址。</li>
</ul>
</li>
<li>从内存方面来说<ul>
<li>基本类型：变量在声明之后，Java 就会立刻分配给他内存空间。</li>
<li>引用类型：它以特殊的方式（类似 C 指针）向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址。</li>
</ul>
</li>
<li>从使用方面来说<ul>
<li>基本类型：使用时需要赋具体值,判断时使用 <code>==</code> 号。</li>
<li>引用类型：使用时可以赋 null，判断时使用 <code>equals</code> 方法。</li>
</ul>
</li>
</ul>
<blockquote>
<p>👉 扩展阅读：<a href="https://juejin.im/post/59cd71835188255d3448faf6">Java 基本数据类型和引用类型</a></p>
<p>这篇文章对于基本数据类型和引用类型的内存存储讲述比较生动。</p>
</blockquote>
<h2 id="2-数据转换"><a href="#2-数据转换" class="headerlink" title="2. 数据转换"></a>2. 数据转换</h2><p>Java 中，数据类型转换有两种方式：</p>
<ul>
<li>自动转换</li>
<li>强制转换</li>
</ul>
<h3 id="2-1-自动转换"><a href="#2-1-自动转换" class="headerlink" title="2.1. 自动转换"></a>2.1. 自动转换</h3><p>一般情况下，定义了某数据类型的变量，就不能再随意转换。但是 JAVA 允许用户对基本类型做<strong>有限度</strong>的类型转换。</p>
<p>如果符合以下条件，则 JAVA 将会自动做类型转换：</p>
<ul>
<li><p><strong>由小数据转换为大数据</strong></p>
<p>显而易见的是，“小”数据类型的数值表示范围小于“大”数据类型的数值表示范围，即精度小于“大”数据类型。</p>
<p>所以，如果“大”数据向“小”数据转换，会丢失数据精度。比如：long 转为 int，则超出 int 表示范围的数据将会丢失，导致结果的不确定性。</p>
<p>反之，“小”数据向“大”数据转换，则不会存在数据丢失情况。由于这个原因，这种类型转换也称为<strong>扩大转换</strong>。</p>
<p>这些类型由“小”到“大”分别为：(byte，short，char) &lt; int &lt; long &lt; float &lt; double。</p>
<p>这里我们所说的“大”与“小”，并不是指占用字节的多少，而是指表示值的范围的大小。</p>
</li>
<li><p><strong>转换前后的数据类型要兼容</strong></p>
<p>由于 boolean 类型只能存放 true 或 false，这与整数或字符是不兼容的，因此不可以做类型转换。</p>
</li>
<li><p><strong>整型类型和浮点型进行计算后，结果会转为浮点类型</strong></p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> x = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">float</span> y = <span class="number">14.3f</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;x/y = &quot;</span> + x/y);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x/y = 1.9607843</span><br></pre></td></tr></table></figure>

<p>可见 long 虽然精度大于 float 类型，但是结果为浮点数类型。</p>
<h3 id="2-2-强制转换"><a href="#2-2-强制转换" class="headerlink" title="2.2. 强制转换"></a>2.2. 强制转换</h3><p>在不符合自动转换条件时或者根据用户的需要，可以对数据类型做强制的转换。</p>
<p><strong>强制转换使用括号 <code>()</code> 。</strong></p>
<p>引用类型也可以使用强制转换。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">25.5f</span>;</span><br><span class="line"><span class="keyword">int</span> x = (<span class="keyword">int</span>)f;</span><br><span class="line">System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br></pre></td></tr></table></figure>

<h2 id="3-装箱和拆箱"><a href="#3-装箱和拆箱" class="headerlink" title="3. 装箱和拆箱"></a>3. 装箱和拆箱</h2><h3 id="3-1-包装类、装箱、拆箱"><a href="#3-1-包装类、装箱、拆箱" class="headerlink" title="3.1. 包装类、装箱、拆箱"></a>3.1. 包装类、装箱、拆箱</h3><p>Java 中为每一种基本数据类型提供了相应的包装类，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Byte &lt;-&gt; byte</span><br><span class="line">Short &lt;-&gt; short</span><br><span class="line">Integer &lt;-&gt; int</span><br><span class="line">Long &lt;-&gt; long</span><br><span class="line">Float &lt;-&gt; float</span><br><span class="line">Double &lt;-&gt; double</span><br><span class="line">Character &lt;-&gt; char</span><br><span class="line">Boolean &lt;-&gt; boolean</span><br></pre></td></tr></table></figure>

<p><strong>引入包装类的目的</strong>就是：提供一种机制，使得<strong>基本数据类型可以与引用类型互相转换</strong>。</p>
<p>基本数据类型与包装类的转换被称为 <code>装箱</code>和 <code>拆箱</code>。</p>
<ul>
<li><strong><code>装箱</code>（boxing）是将值类型转换为引用类型</strong>。例如：<code>int</code> 转 <code>Integer</code><ul>
<li>装箱过程是通过调用包装类的 <code>valueOf</code> 方法实现的。</li>
</ul>
</li>
<li><strong><code>拆箱</code>（unboxing）是将引用类型转换为值类型</strong>。例如：<code>Integer</code> 转 <code>int</code><ul>
<li>拆箱过程是通过调用包装类的 <code>xxxValue</code> 方法实现的。（xxx 代表对应的基本数据类型）。</li>
</ul>
</li>
</ul>
<h3 id="3-2-自动装箱、自动拆箱"><a href="#3-2-自动装箱、自动拆箱" class="headerlink" title="3.2. 自动装箱、自动拆箱"></a>3.2. 自动装箱、自动拆箱</h3><p>基本数据（Primitive）型的自动装箱（boxing）拆箱（unboxing）自 JDK 5 开始提供的功能。</p>
<p>自动装箱与拆箱的机制可以让我们在 Java 的变量赋值或者是方法调用等情况下使用原始类型或者对象类型更加简单直接。<br>因为自动装箱会隐式地创建对象，如果在一个循环体中，会创建无用的中间对象，这样会增加 GC 压力，拉低程序的性能。所以在写循环时一定要注意代码，避免引入不必要的自动装箱操作。</p>
<p>JDK 5 之前的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="keyword">new</span> Integer(<span class="number">10</span>); <span class="comment">// 非自动装箱</span></span><br></pre></td></tr></table></figure>

<p>JDK 5 之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i2 = <span class="number">10</span>; <span class="comment">// 自动装箱</span></span><br></pre></td></tr></table></figure>

<p>Java 对于自动装箱和拆箱的设计，依赖于一种叫做享元模式的设计模式（有兴趣的朋友可以去了解一下源码，这里不对设计模式展开详述）。</p>
<blockquote>
<p>👉 扩展阅读：<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析 Java 中的装箱和拆箱</a></p>
<p>结合示例，一步步阐述装箱和拆箱原理。</p>
</blockquote>
<h3 id="3-3-装箱、拆箱的应用和注意点"><a href="#3-3-装箱、拆箱的应用和注意点" class="headerlink" title="3.3. 装箱、拆箱的应用和注意点"></a>3.3. 装箱、拆箱的应用和注意点</h3><h4 id="装箱、拆箱应用场景"><a href="#装箱、拆箱应用场景" class="headerlink" title="装箱、拆箱应用场景"></a>装箱、拆箱应用场景</h4><ul>
<li>一种最普通的场景是：调用一个<strong>含类型为 <code>Object</code> 参数的方法</strong>，该 <code>Object</code> 可支持任意类型（因为 <code>Object</code> 是所有类的父类），以便通用。当你需要将一个值类型（如 int）传入时，需要使用 <code>Integer</code> 装箱。</li>
<li>另一种用法是：一个<strong>非泛型的容器</strong>，同样是为了保证通用，而将元素类型定义为 <code>Object</code>。于是，要将值类型数据加入容器时，需要装箱。</li>
<li>当 <code>==</code> 运算符的两个操作，一个操作数是包装类，另一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。</li>
</ul>
<p>【示例】装箱、拆箱示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">10</span>; <span class="comment">// 自动装箱</span></span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">10</span>); <span class="comment">// 非自动装箱</span></span><br><span class="line">Integer i3 = Integer.valueOf(<span class="number">10</span>); <span class="comment">// 非自动装箱</span></span><br><span class="line"><span class="keyword">int</span> i4 = <span class="keyword">new</span> Integer(<span class="number">10</span>); <span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> i5 = i2.intValue(); <span class="comment">// 非自动拆箱</span></span><br><span class="line">System.out.println(<span class="string">&quot;i1 = [&quot;</span> + i1 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;i2 = [&quot;</span> + i2 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;i3 = [&quot;</span> + i3 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;i4 = [&quot;</span> + i4 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;i5 = [&quot;</span> + i5 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;i1 == i2 is [&quot;</span> + (i1 == i2) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;i1 == i4 is [&quot;</span> + (i1 == i4) + <span class="string">&quot;]&quot;</span>); <span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// i1 = [10]</span></span><br><span class="line"><span class="comment">// i2 = [10]</span></span><br><span class="line"><span class="comment">// i3 = [10]</span></span><br><span class="line"><span class="comment">// i4 = [10]</span></span><br><span class="line"><span class="comment">// i5 = [10]</span></span><br><span class="line"><span class="comment">// i1 == i2 is [false]</span></span><br><span class="line"><span class="comment">// i1 == i4 is [true]</span></span><br></pre></td></tr></table></figure>

<p>【说明】</p>
<p>上面的例子，虽然简单，但却隐藏了自动装箱、拆箱和非自动装箱、拆箱的应用。从例子中可以看到，明明所有变量都初始化为数值 10 了，但为何会出现 <code>i1 == i2 is [false</code> 而 <code>i1 == i4 is [true]</code> ？</p>
<p>原因在于：</p>
<ul>
<li>i1、i2 都是包装类，使用 <code>==</code> 时，Java 将它们当做两个对象，而非两个 int 值来比较，所以两个对象自然是不相等的。正确的比较操作应该使用 <code>equals</code> 方法。</li>
<li>i1 是包装类，i4 是基础数据类型，使用 <code>==</code> 时，Java 会将两个 i1 这个包装类对象自动拆箱为一个 <code>int</code> 值，再代入到 <code>==</code> 运算表达式中计算；最终，相当于两个 <code>int</code> 进行比较，由于值相同，所以结果相等。</li>
</ul>
<p>【示例】包装类判等问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line">Integer b = <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger a = 127;\nInteger b = 127;\na == b ? &#123;&#125;&quot;</span>, a == b);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Integer c = <span class="number">128</span>; <span class="comment">//Integer.valueOf(128)</span></span><br><span class="line">Integer d = <span class="number">128</span>; <span class="comment">//Integer.valueOf(128)</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger c = 128;\nInteger d = 128;\nc == d ? &#123;&#125;&quot;</span>, c == d);   <span class="comment">//false</span></span><br><span class="line"><span class="comment">//设置-XX:AutoBoxCacheMax=1000再试试</span></span><br><span class="line"></span><br><span class="line">Integer e = <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line">Integer f = <span class="keyword">new</span> Integer(<span class="number">127</span>); <span class="comment">//new instance</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger e = 127;\nInteger f = new Integer(127);\ne == f ? &#123;&#125;&quot;</span>, e == f);   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer g = <span class="keyword">new</span> Integer(<span class="number">127</span>); <span class="comment">//new instance</span></span><br><span class="line">Integer h = <span class="keyword">new</span> Integer(<span class="number">127</span>); <span class="comment">//new instance</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger g = new Integer(127);\nInteger h = new Integer(127);\ng == h ? &#123;&#125;&quot;</span>, g == h);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="number">128</span>; <span class="comment">//unbox</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">128</span>;</span><br><span class="line">log.info(<span class="string">&quot;\nInteger i = 128;\nint j = 128;\ni == j ? &#123;&#125;&quot;</span>, i == j); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>通过运行结果可以看到，虽然看起来永远是在对 127 和 127、128 和 128 判等，但 == 却并非总是返回 true。</p>
<h4 id="装箱、拆箱应用注意点"><a href="#装箱、拆箱应用注意点" class="headerlink" title="装箱、拆箱应用注意点"></a>装箱、拆箱应用注意点</h4><ol>
<li>装箱操作会创建对象，频繁的装箱操作会造成不必要的内存消耗，影响性能。所以<strong>应该尽量避免装箱。</strong></li>
<li>基础数据类型的比较操作使用 <code>==</code>，包装类的比较操作使用 <code>equals</code> 方法。</li>
</ol>
<h2 id="4-判等问题"><a href="#4-判等问题" class="headerlink" title="4. 判等问题"></a>4. 判等问题</h2><p>Java 中，通常使用 <code>equals</code> 或 <code>==</code> 进行判等操作。<code>equals</code> 是方法而 <code>==</code> 是操作符。此外，二者使用也是有区别的：</p>
<ul>
<li>对<strong>基本类型</strong>，比如 <code>int</code>、<code>long</code>，进行判等，<strong>只能使用 <code>==</code>，比较的是字面值</strong>。因为基本类型的值就是其数值。</li>
<li>对<strong>引用类型</strong>，比如 <code>Integer</code>、<code>Long</code> 和 <code>String</code>，进行判等，<strong>需要使用 <code>equals</code> 进行内容判等</strong>。因为引用类型的直接值是指针，使用 <code>==</code> 的话，比较的是指针，也就是两个对象在内存中的地址，即比较它们是不是同一个对象，而不是比较对象的内容。</li>
</ul>
<h3 id="4-1-包装类的判等"><a href="#4-1-包装类的判等" class="headerlink" title="4.1. 包装类的判等"></a>4.1. 包装类的判等</h3><p>我们通过一个示例来深入研究一下判等问题。</p>
<p>【示例】包装类的判等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line">Integer b = <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger a = 127;\nInteger b = 127;\na == b ? &#123;&#125;&quot;</span>, a == b);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Integer c = <span class="number">128</span>; <span class="comment">//Integer.valueOf(128)</span></span><br><span class="line">Integer d = <span class="number">128</span>; <span class="comment">//Integer.valueOf(128)</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger c = 128;\nInteger d = 128;\nc == d ? &#123;&#125;&quot;</span>, c == d);   <span class="comment">//false</span></span><br><span class="line"><span class="comment">//设置-XX:AutoBoxCacheMax=1000再试试</span></span><br><span class="line"></span><br><span class="line">Integer e = <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line">Integer f = <span class="keyword">new</span> Integer(<span class="number">127</span>); <span class="comment">//new instance</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger e = 127;\nInteger f = new Integer(127);\ne == f ? &#123;&#125;&quot;</span>, e == f);   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer g = <span class="keyword">new</span> Integer(<span class="number">127</span>); <span class="comment">//new instance</span></span><br><span class="line">Integer h = <span class="keyword">new</span> Integer(<span class="number">127</span>); <span class="comment">//new instance</span></span><br><span class="line">log.info(<span class="string">&quot;\nInteger g = new Integer(127);\nInteger h = new Integer(127);\ng == h ? &#123;&#125;&quot;</span>, g == h);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="number">128</span>; <span class="comment">//unbox</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">128</span>;</span><br><span class="line">log.info(<span class="string">&quot;\nInteger i = 128;\nint j = 128;\ni == j ? &#123;&#125;&quot;</span>, i == j); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>第一个案例中，编译器会把 Integer a = 127 转换为 Integer.valueOf(127)。查看源码可以发现，这个转换在内部其实做了缓存，使得两个 Integer 指向同一个对象，所以 == 返回 true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个案例中，之所以同样的代码 128 就返回 false 的原因是，默认情况下会缓存[-128,127]的数值，而 128 处于这个区间之外。设置 JVM 参数加上 -XX:AutoBoxCacheMax=1000 再试试，是不是就返回 true 了呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三和第四个案例中，New 出来的 Integer 始终是不走缓存的新对象。比较两个新对象，或者比较一个新对象和一个来自缓存的对象，结果肯定不是相同的对象，因此返回 false。</p>
<p>第五个案例中，我们把装箱的 Integer 和基本类型 int 比较，前者会先拆箱再比较，比较的肯定是数值而不是引用，因此返回 true。</p>
<blockquote>
<p>【总结】综上，我们可以得出结论：**包装类需要使用 <code>equals</code> 进行内容判等，而不能使用 <code>==</code>**。</p>
</blockquote>
<h3 id="4-2-String-的判等"><a href="#4-2-String-的判等" class="headerlink" title="4.2. String 的判等"></a>4.2. String 的判等</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">log.info(<span class="string">&quot;\nString a = \&quot;1\&quot;;\nString b = \&quot;1\&quot;;\na == b ? &#123;&#125;&quot;</span>, a == b); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">String d = <span class="keyword">new</span> String(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;\nString c = new String(\&quot;2\&quot;);\nString d = new String(\&quot;2\&quot;);\nc == d ? &#123;&#125;&quot;</span>, c == d); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">String e = <span class="keyword">new</span> String(<span class="string">&quot;3&quot;</span>).intern();</span><br><span class="line">String f = <span class="keyword">new</span> String(<span class="string">&quot;3&quot;</span>).intern();</span><br><span class="line">log.info(<span class="string">&quot;\nString e = new String(\&quot;3\&quot;).intern();\nString f = new String(\&quot;3\&quot;).intern();\ne == f ? &#123;&#125;&quot;</span>, e == f); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">String g = <span class="keyword">new</span> String(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">String h = <span class="keyword">new</span> String(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">log.info(<span class="string">&quot;\nString g = new String(\&quot;4\&quot;);\nString h = new String(\&quot;4\&quot;);\ng == h ? &#123;&#125;&quot;</span>, g.equals(h)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>在 JVM 中，当代码中出现双引号形式创建字符串对象时，JVM 会先对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。这种机制，就是字符串驻留或池化。</p>
<p>第一个案例返回 true，因为 Java 的字符串驻留机制，直接使用双引号声明出来的两个 String 对象指向常量池中的相同字符串。</p>
<p>第二个案例，new 出来的两个 String 是不同对象，引用当然不同，所以得到 false 的结果。</p>
<p>第三个案例，使用 String 提供的 intern 方法也会走常量池机制，所以同样能得到 true。</p>
<p>第四个案例，通过 equals 对值内容判等，是正确的处理方式，当然会得到 true。</p>
<p>虽然使用 new 声明的字符串调用 intern 方法，也可以让字符串进行驻留，但在业务代码中滥用 intern，可能会产生性能问题。</p>
<p>【示例】String#intern 性能测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-XX:+PrintStringTableStatistics</span></span><br><span class="line"><span class="comment">//-XX:StringTableSize=10000000</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">list = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">10000000</span>)</span><br><span class="line">    .mapToObj(i -&gt; String.valueOf(i).intern())</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;size:&quot;</span> + list.size());</span><br><span class="line">System.out.println(<span class="string">&quot;time:&quot;</span> + (System.currentTimeMillis() - begin));</span><br></pre></td></tr></table></figure>

<p>上面的示例执行时间会比较长。原因在于：字符串常量池是一个固定容量的 Map。如果容量太小（Number of<br>buckets=60013）、字符串太多（1000 万个字符串），那么每一个桶中的字符串数量会非常多，所以搜索起来就很慢。输出结果中的 Average bucket size=167，代表了 Map 中桶的平均长度是 167。</p>
<p>解决方法是：设置 JVM 参数 -XX:StringTableSize=10000000，指定更多的桶。</p>
<p>为了方便观察，可以在启动程序时设置 JVM 参数 -XX:+PrintStringTableStatistic，程序退出时可以打印出字符串常量表的统计信息。</p>
<p>执行结果比不设置 -XX:StringTableSize 要快很多。</p>
<blockquote>
<p>【总结】<strong>没事别轻易用 intern，如果要用一定要注意控制驻留的字符串的数量，并留意常量表的各项指标</strong>。</p>
</blockquote>
<h3 id="4-3-实现-equals"><a href="#4-3-实现-equals" class="headerlink" title="4.3. 实现 equals"></a>4.3. 实现 equals</h3><p>如果看过 Object 类源码，你可能就知道，equals 的实现其实是比较对象引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以 Integer 或 String 能通过 equals 实现内容判等，是因为它们都覆写了这个方法。</p>
<p>对于自定义类型，如果不覆写 equals 的话，默认就是使用 Object 基类的按引用的比较方式。</p>
<p>实现一个更好的 equals 应该注意的点：</p>
<ul>
<li>考虑到性能，可以先进行指针判等，如果对象是同一个那么直接返回 true；</li>
<li>需要对另一方进行判空，空对象和自身进行比较，结果一定是 fasle；</li>
<li>需要判断两个对象的类型，如果类型都不同，那么直接返回 false；</li>
<li>确保类型相同的情况下再进行类型强制转换，然后逐一判断所有字段。</li>
</ul>
<p>【示例】自定义 equals 示例</p>
<p>自定义类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义 equals：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Point that = (Point) o;</span><br><span class="line">    <span class="keyword">return</span> x == that.x &amp;&amp; y == that.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-hashCode-和-equals-要配对实现"><a href="#4-4-hashCode-和-equals-要配对实现" class="headerlink" title="4.4. hashCode 和 equals 要配对实现"></a>4.4. hashCode 和 equals 要配对实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Point p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">Point p2 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">HashSet&lt;PointWrong&gt; points = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">points.add(p1);</span><br><span class="line">log.info(<span class="string">&quot;points.contains(p2) ? &#123;&#125;&quot;</span>, points.contains(p2));</span><br></pre></td></tr></table></figure>

<p>按照改进后的 equals 方法，这 2 个对象可以认为是同一个，Set 中已经存在了 p1 就应该包含 p2，但结果却是 false。</p>
<p>出现这个 Bug 的原因是，散列表需要使用 hashCode 来定位元素放到哪个桶。如果自定义对象没有实现自定义的 hashCode 方法，就会使用 Object 超类的默认实现，得到的两个 hashCode 是不同的，导致无法满足需求。</p>
<p>要自定义 hashCode，我们可以直接使用 Objects.hash 方法来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-compareTo-和-equals-的逻辑一致性"><a href="#4-5-compareTo-和-equals-的逻辑一致性" class="headerlink" title="4.5. compareTo 和 equals 的逻辑一致性"></a>4.5. compareTo 和 equals 的逻辑一致性</h3><p>【示例】自定义 compareTo 出错示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = Integer.compare(other.id, id);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123; log.info(<span class="string">&quot;this &#123;&#125; == other &#123;&#125;&quot;</span>, <span class="keyword">this</span>, other); &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">&quot;zhang&quot;</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">&quot;wang&quot;</span>));</span><br><span class="line">Student student = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">&quot;li&quot;</span>);</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;ArrayList.indexOf&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> index1 = list.indexOf(student);</span><br><span class="line">Collections.sort(list);</span><br><span class="line">log.info(<span class="string">&quot;Collections.binarySearch&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> index2 = Collections.binarySearch(list, student);</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;index1 = &quot;</span> + index1);</span><br><span class="line">log.info(<span class="string">&quot;index2 = &quot;</span> + index2);</span><br></pre></td></tr></table></figure>

<p>binarySearch 方法内部调用了元素的 compareTo 方法进行比较；</p>
<ul>
<li>indexOf 的结果没问题，列表中搜索不到 id 为 2、name 是 li 的学生；</li>
<li>binarySearch 返回了索引 1，代表搜索到的结果是 id 为 2，name 是 wang 的学生。</li>
</ul>
<p>修复方式很简单，确保 compareTo 的比较逻辑和 equals 的实现一致即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentRight</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">StudentRight</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(StudentRight other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Comparator.comparing(StudentRight::getName)</span><br><span class="line">            .thenComparingInt(StudentRight::getId)</span><br><span class="line">            .compare(<span class="keyword">this</span>, other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-小心-Lombok-生成代码的“坑”"><a href="#4-6-小心-Lombok-生成代码的“坑”" class="headerlink" title="4.6. 小心 Lombok 生成代码的“坑”"></a>4.6. 小心 Lombok 生成代码的“坑”</h3><p>Lombok 的 @Data 注解会帮我们实现 equals 和 hashcode 方法，但是有继承关系时，<br>Lombok 自动生成的方法可能就不是我们期望的了。</p>
<p>@EqualsAndHashCode 默认实现没有使用父类属性。为解决这个问题，我们可以手动设置 callSuper 开关为 true，来覆盖这种默认行为。</p>
<h2 id="5-数值计算"><a href="#5-数值计算" class="headerlink" title="5. 数值计算"></a>5. 数值计算</h2><h3 id="5-1-浮点数计算问题"><a href="#5-1-浮点数计算问题" class="headerlink" title="5.1. 浮点数计算问题"></a>5.1. 浮点数计算问题</h3><p>计算机是把数值保存在了变量中，不同类型的数值变量能保存的数值范围不同，当数值超过类型能表达的数值上限则会发生溢出问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">0.1</span> + <span class="number">0.2</span>); <span class="comment">// 0.30000000000000004</span></span><br><span class="line">System.out.println(<span class="number">1.0</span> - <span class="number">0.8</span>); <span class="comment">// 0.19999999999999996</span></span><br><span class="line">System.out.println(<span class="number">4.015</span> * <span class="number">100</span>); <span class="comment">// 401.49999999999994</span></span><br><span class="line">System.out.println(<span class="number">123.3</span> / <span class="number">100</span>); <span class="comment">// 1.2329999999999999</span></span><br><span class="line"><span class="keyword">double</span> amount1 = <span class="number">2.15</span>;</span><br><span class="line"><span class="keyword">double</span> amount2 = <span class="number">1.10</span>;</span><br><span class="line">System.out.println(amount1 - amount2); <span class="comment">// 1.0499999999999998</span></span><br></pre></td></tr></table></figure>

<p>上面的几个示例，输出结果和我们预期的很不一样。为什么会是这样呢？</p>
<p>出现这种问题的主要原因是，计算机是以二进制存储数值的，浮点数也不例外。Java 采用了 IEEE 754 标准实现浮点数的表达和运算，你可以通过这里查看数值转化为二进制的结果。</p>
<p>比如，0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，再转换为十进制就是 0.1000000000000000055511151231257827021181583404541015625。对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。</p>
<p><strong>浮点数无法精确表达和运算的场景，一定要使用 BigDecimal 类型</strong>。</p>
<p>使用 BigDecimal 时，有个细节要格外注意。让我们来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> BigDecimal(<span class="number">0.1</span>).add(<span class="keyword">new</span> BigDecimal(<span class="number">0.2</span>)));</span><br><span class="line"><span class="comment">// Output: 0.3000000000000000166533453693773481063544750213623046875</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> BigDecimal(<span class="number">1.0</span>).subtract(<span class="keyword">new</span> BigDecimal(<span class="number">0.8</span>)));</span><br><span class="line"><span class="comment">// Output: 0.1999999999999999555910790149937383830547332763671875</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> BigDecimal(<span class="number">4.015</span>).multiply(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>)));</span><br><span class="line"><span class="comment">// Output: 401.49999999999996802557689079549163579940795898437500</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="keyword">new</span> BigDecimal(<span class="number">123.3</span>).divide(<span class="keyword">new</span> BigDecimal(<span class="number">100</span>)));</span><br><span class="line"><span class="comment">// Output: 1.232999999999999971578290569595992565155029296875</span></span><br></pre></td></tr></table></figure>

<p>为什么输出结果仍然不符合预期呢？</p>
<p><strong>使用 BigDecimal 表示和计算浮点数，且务必使用字符串的构造方法来初始化 BigDecimal</strong>。</p>
<h3 id="5-2-浮点数精度和格式化"><a href="#5-2-浮点数精度和格式化" class="headerlink" title="5.2. 浮点数精度和格式化"></a>5.2. 浮点数精度和格式化</h3><p><strong>浮点数的字符串格式化也要通过 BigDecimal 进行</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrong1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num1 = <span class="number">3.35</span>;</span><br><span class="line">    <span class="keyword">float</span> num2 = <span class="number">3.35f</span>;</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;%.1f&quot;</span>, num1)); <span class="comment">// 3.4</span></span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;%.1f&quot;</span>, num2)); <span class="comment">// 3.3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrong2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num1 = <span class="number">3.35</span>;</span><br><span class="line">    <span class="keyword">float</span> num2 = <span class="number">3.35f</span>;</span><br><span class="line">    DecimalFormat format = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;#.##&quot;</span>);</span><br><span class="line">    format.setRoundingMode(RoundingMode.DOWN);</span><br><span class="line">    System.out.println(format.format(num1)); <span class="comment">// 3.35</span></span><br><span class="line">    format.setRoundingMode(RoundingMode.DOWN);</span><br><span class="line">    System.out.println(format.format(num2)); <span class="comment">// 3.34</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigDecimal num1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;3.35&quot;</span>);</span><br><span class="line">    BigDecimal num2 = num1.setScale(<span class="number">1</span>, BigDecimal.ROUND_DOWN);</span><br><span class="line">    System.out.println(num2); <span class="comment">// 3.3</span></span><br><span class="line">    BigDecimal num3 = num1.setScale(<span class="number">1</span>, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">    System.out.println(num3); <span class="comment">// 3.4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-BigDecimal-判等问题"><a href="#5-3-BigDecimal-判等问题" class="headerlink" title="5.3. BigDecimal 判等问题"></a>5.3. BigDecimal 判等问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>).equals(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>).compareTo(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1&quot;</span>)) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BigDecimal 的 equals 方法的注释中说明了原因，equals 比较的是 BigDecimal 的 value 和 scale，1.0 的 scale 是 1，1 的 scale 是 0，所以结果一定是 false。</p>
<p><strong>如果我们希望只比较 BigDecimal 的 value，可以使用 compareTo 方法</strong>。</p>
<p>BigDecimal 的 equals 和 hashCode 方法会同时考虑 value 和 scale，如果结合 HashSet 或 HashMap 使用的话就可能会出现麻烦。比如，我们把值为 1.0 的 BigDecimal 加入 HashSet，然后判断其是否存在值为 1 的 BigDecimal，得到的结果是 false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;BigDecimal&gt; hashSet1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">hashSet1.add(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>));</span><br><span class="line">System.out.println(hashSet1.contains(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1&quot;</span>)));<span class="comment">//返回false</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解决办法有两个：</p>
<p>第一个方法是，使用 TreeSet 替换 HashSet。TreeSet 不使用 hashCode 方法，也不使用 equals 比较元素，而是使用 compareTo 方法，所以不会有问题。</p>
<p>第二个方法是，把 BigDecimal 存入 HashSet 或 HashMap 前，先使用 stripTrailingZeros 方法去掉尾部的零，比较的时候也去掉尾部的 0，确保 value 相同的 BigDecimal，scale 也是一致的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;BigDecimal&gt; hashSet2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">hashSet2.add(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>).stripTrailingZeros());</span><br><span class="line">System.out.println(hashSet2.contains(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.000&quot;</span>).stripTrailingZeros()));<span class="comment">//返回true</span></span><br><span class="line"></span><br><span class="line">Set&lt;BigDecimal&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">treeSet.add(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>));</span><br><span class="line">System.out.println(treeSet.contains(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1&quot;</span>)));<span class="comment">//返回true</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4-数值溢出"><a href="#5-4-数值溢出" class="headerlink" title="5.4. 数值溢出"></a>5.4. 数值溢出</h3><p>数值计算还有一个要小心的点是溢出，不管是 int 还是 long，所有的基本数值类型都有超出表达范围的可能性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> l = Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>显然这是发生了溢出，而且是默默的溢出，并没有任何异常</strong>。这类问题非常容易被忽略，改进方式有下面 2 种。</p>
<p>方法一是，考虑使用 Math 类的 addExact、subtractExact 等 xxExact 方法进行数值运算，这些方法可以在数值溢出时主动抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> l = Long.MAX_VALUE;</span><br><span class="line">    System.out.println(Math.addExact(l, <span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二是，使用大数类 BigInteger。BigDecimal 是处理浮点数的专家，而 BigInteger 则是对大数进行科学计算的专家。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger i = <span class="keyword">new</span> BigInteger(String.valueOf(Long.MAX_VALUE));</span><br><span class="line">System.out.println(i.add(BigInteger.ONE).toString());</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> l = i.add(BigInteger.ONE).longValueExact();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/2130190/">《Java 编程思想（Thinking in java）》</a></li>
<li><a href="https://book.douban.com/subject/26880667/">《Java 核心技术 卷 I 基础知识》</a></li>
<li><a href="https://time.geekbang.org/column/intro/100047701">《Java 业务开发常见错误 100 例》</a></li>
<li><a href="https://juejin.im/post/59cd71835188255d3448faf6">Java 基本数据类型和引用类型</a></li>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析 Java 中的装箱和拆箱</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Java 常用工具类</title>
    <url>/2021/12/06/java-common-tool-class/</url>
    <content><![CDATA[<h1 id="Java-常用工具类"><a href="#Java-常用工具类" class="headerlink" title="Java 常用工具类"></a>Java 常用工具类</h1><blockquote>
<p><strong>📦 本文以及示例源码已归档在 <a href="https://github.com/dunwu/javacore/">javacore</a></strong></p>
<p>并发、IO、容器的工具类不会在本文提及，后面会有专题一一道来。</p>
</blockquote>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><h2 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a>日期时间</h2><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/2130190/">Java编程思想</a></li>
<li><a href="https://book.douban.com/subject/3146174/">Java核心技术（卷 1）</a></li>
</ul>
]]></content>
      <categories>
        <category>java工具</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础语法特性</title>
    <url>/2021/12/06/java-basic-grammar/</url>
    <content><![CDATA[<h1 id="Java-基础语法特性"><a href="#Java-基础语法特性" class="headerlink" title="Java 基础语法特性"></a>Java 基础语法特性</h1><blockquote>
<p><strong>📦 本文以及示例源码已归档在 <a href="https://github.com/dunwu/javacore/">javacore</a></strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->

<ul>
<li><a href="#1-%E6%B3%A8%E9%87%8A">1. 注释</a></li>
<li><a href="#2-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2. 基本数据类型</a></li>
<li><a href="#3-%E5%8F%98%E9%87%8F">3. 变量</a></li>
<li><a href="#4-%E6%95%B0%E7%BB%84">4. 数组</a></li>
<li><a href="#5-%E6%9E%9A%E4%B8%BE">5. 枚举</a></li>
<li><a href="#6-%E6%93%8D%E4%BD%9C%E7%AC%A6">6. 操作符</a></li>
<li><a href="#7-%E6%96%B9%E6%B3%95">7. 方法</a></li>
<li><a href="#8-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">8. 控制语句</a></li>
<li><a href="#9-%E5%BC%82%E5%B8%B8">9. 异常</a></li>
<li><a href="#10-%E6%B3%9B%E5%9E%8B">10. 泛型</a></li>
<li><a href="#11-%E5%8F%8D%E5%B0%84">11. 反射</a></li>
<li><a href="#12-%E6%B3%A8%E8%A7%A3">12. 注解</a></li>
<li><a href="#13-%E5%BA%8F%E5%88%97%E5%8C%96">13. 序列化</a></li>
<li><a href="#14-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">14. 参考资料</a></li>
</ul>
<!-- /TOC -->

<h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h2><p>空白行，或者注释的内容，都会被 Java 编译器忽略掉。</p>
<p>Java 支持多种注释方式，下面的示例展示了各种注释的使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * JavaDoc 注释</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单行注释</span></span><br><span class="line">        <span class="comment">/* 多行注释：</span></span><br><span class="line"><span class="comment">           1. 注意点a</span></span><br><span class="line"><span class="comment">           2. 注意点b</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-基本数据类型"><a href="#2-基本数据类型" class="headerlink" title="2. 基本数据类型"></a>2. 基本数据类型</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.svg" alt="img"></p>
<blockquote>
<p>👉 扩展阅读：<a href="https://github.com/dunwu/javacore/blob/master/docs/basics/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md">深入理解 Java 基本数据类型</a></p>
</blockquote>
<h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h2><p>Java 支持的变量类型有：</p>
<ul>
<li><code>局部变量</code> - 类方法中的变量。</li>
<li><code>实例变量（也叫成员变量）</code> - 类方法外的变量，不过没有 <code>static</code> 修饰。</li>
<li><code>类变量（也叫静态变量）</code> - 类方法外的变量，用 <code>static</code> 修饰。</li>
</ul>
<p>特性对比：</p>
<table>
<thead>
<tr>
<th>局部变量</th>
<th>实例变量（也叫成员变量）</th>
<th>类变量（也叫静态变量）</th>
</tr>
</thead>
<tbody><tr>
<td>局部变量声明在方法、构造方法或者语句块中。</td>
<td>实例变量声明在方法、构造方法和语句块之外。</td>
<td>类变量声明在方法、构造方法和语句块之外。并且以 static 修饰。</td>
</tr>
<tr>
<td>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。</td>
<td>实例变量在对象创建的时候创建，在对象被销毁的时候销毁。</td>
<td>类变量在第一次被访问时创建，在程序结束时销毁。</td>
</tr>
<tr>
<td>局部变量没有默认值，所以必须经过初始化，才可以使用。</td>
<td>实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。</td>
<td>类变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</td>
</tr>
<tr>
<td>对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。</td>
<td>实例变量存储在堆。</td>
<td>类变量存储在静态存储区。</td>
</tr>
<tr>
<td>访问修饰符不能用于局部变量。</td>
<td>访问修饰符可以用于实例变量。</td>
<td>访问修饰符可以用于类变量。</td>
</tr>
<tr>
<td>局部变量只在声明它的方法、构造方法或者语句块中可见。</td>
<td>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见。</td>
<td>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</td>
</tr>
<tr>
<td></td>
<td>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</td>
<td>静态变量可以通过：ClassName.VariableName 的方式访问。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</td>
</tr>
<tr>
<td></td>
<td></td>
<td>类变量除了被声明为常量外很少使用。</td>
</tr>
</tbody></table>
<p><strong>变量修饰符</strong></p>
<ul>
<li><strong>访问级别修饰符</strong><ul>
<li>如果变量是实例变量或类变量，可以添加访问级别修饰符（public/protected/private）</li>
</ul>
</li>
<li><strong>静态修饰符</strong><ul>
<li>如果变量是类变量，需要添加 static 修饰</li>
</ul>
</li>
<li><strong>final</strong><ul>
<li>如果变量使用 <code>fianl</code> 修饰符，就表示这是一个常量，不能被修改。</li>
</ul>
</li>
</ul>
<h2 id="4-数组"><a href="#4-数组" class="headerlink" title="4. 数组"></a>4. 数组</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/Java%E6%95%B0%E7%BB%84.svg" alt="img"></p>
<blockquote>
<p>👉 扩展阅读：<a href="https://github.com/dunwu/javacore/blob/master/docs/basics/Java%E6%95%B0%E7%BB%84.md">深入理解 Java 数组</a></p>
</blockquote>
<h2 id="5-枚举"><a href="#5-枚举" class="headerlink" title="5. 枚举"></a>5. 枚举</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/Java%E6%9E%9A%E4%B8%BE.svg" alt="img"></p>
<blockquote>
<p>👉 扩展阅读：<a href="https://github.com/dunwu/javacore/blob/master/docs/basics/Java%E6%9E%9A%E4%B8%BE.md">深入理解 Java 数组</a></p>
</blockquote>
<h2 id="6-操作符"><a href="#6-操作符" class="headerlink" title="6. 操作符"></a>6. 操作符</h2><p>Java 中支持的操作符类型如下：</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/Java%E6%93%8D%E4%BD%9C%E7%AC%A6.svg" alt="img"></p>
<blockquote>
<p>👉 扩展阅读：<a href="http://www.runoob.com/java/java-operators.html">Java 操作符</a></p>
</blockquote>
<h2 id="7-方法"><a href="#7-方法" class="headerlink" title="7. 方法"></a>7. 方法</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/Java%E6%96%B9%E6%B3%95.svg" alt="img"></p>
<blockquote>
<p>👉 扩展阅读：<a href="https://github.com/dunwu/javacore/blob/master/docs/basics/Java%E6%96%B9%E6%B3%95.md">深入理解 Java 方法</a></p>
</blockquote>
<h2 id="8-控制语句"><a href="#8-控制语句" class="headerlink" title="8. 控制语句"></a>8. 控制语句</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/Java%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.svg" alt="img"></p>
<blockquote>
<p>👉 扩展阅读：<a href="https://github.com/dunwu/javacore/blob/master/docs/basics/Java%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.md">Java 控制语句</a></p>
</blockquote>
<h2 id="9-异常"><a href="#9-异常" class="headerlink" title="9. 异常"></a>9. 异常</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/Java%E5%BC%82%E5%B8%B8%E6%A1%86%E6%9E%B6.svg" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/Java%E5%BC%82%E5%B8%B8.svg" alt="img"></p>
<blockquote>
<p>👉 扩展阅读：<a href="https://github.com/dunwu/javacore/blob/master/docs/basics/Java%E5%BC%82%E5%B8%B8.md">深入理解 Java 异常</a></p>
</blockquote>
<h2 id="10-泛型"><a href="#10-泛型" class="headerlink" title="10. 泛型"></a>10. 泛型</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/Java%E6%B3%9B%E5%9E%8B.svg" alt="img"></p>
<blockquote>
<p>👉 扩展阅读：<a href="https://github.com/dunwu/javacore/blob/master/docs/basics/Java%E6%B3%9B%E5%9E%8B.md">深入理解 Java 泛型</a></p>
</blockquote>
<h2 id="11-反射"><a href="#11-反射" class="headerlink" title="11. 反射"></a>11. 反射</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/Java%E5%8F%8D%E5%B0%84.svg" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/Java%E4%BB%A3%E7%90%86.svg" alt="img"></p>
<blockquote>
<p>👉 扩展阅读：<a href="https://github.com/dunwu/javacore/blob/master/docs/basics/Java%E5%8F%8D%E5%B0%84.md">深入理解 Java 反射和动态代理</a></p>
</blockquote>
<h2 id="12-注解"><a href="#12-注解" class="headerlink" title="12. 注解"></a>12. 注解</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/%E6%B3%A8%E8%A7%A3%E7%AE%80%E4%BB%8B.svg" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/%E5%85%83%E6%B3%A8%E8%A7%A3.svg" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3.svg" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3.svg" alt="img"></p>
<blockquote>
<p>👉 扩展阅读：<a href="https://github.com/dunwu/javacore/blob/master/docs/basics/Java%E6%B3%A8%E8%A7%A3.md">深入理解 Java 注解</a></p>
</blockquote>
<h2 id="13-序列化"><a href="#13-序列化" class="headerlink" title="13. 序列化"></a>13. 序列化</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/Java%E5%BA%8F%E5%88%97%E5%8C%96.svg" alt="img"></p>
<blockquote>
<p>👉 扩展阅读：<a href="https://github.com/dunwu/javacore/blob/master/docs/io/Java%E5%BA%8F%E5%88%97%E5%8C%96.md">深入理解 Java 序列化</a></p>
</blockquote>
<h2 id="14-参考资料"><a href="#14-参考资料" class="headerlink" title="14. 参考资料"></a>14. 参考资料</h2>]]></content>
      <categories>
        <category>java基础语法</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java 数组</title>
    <url>/2021/12/06/java-array/</url>
    <content><![CDATA[<h1 id="深入理解-Java-数组"><a href="#深入理解-Java-数组" class="headerlink" title="深入理解 Java 数组"></a>深入理解 Java 数组</h1><blockquote>
<p><strong>📦 本文以及示例源码已归档在 <a href="https://github.com/dunwu/javacore/">javacore</a></strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->

<ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B">1. 简介</a><ul>
<li><a href="#11-%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E6%80%A7">1.1. 数组的特性</a></li>
<li><a href="#12-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AE%B9%E5%99%A8">1.2. 数组和容器</a></li>
<li><a href="#13-java-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E5%AF%B9%E8%B1%A1">1.3. Java 数组的本质是对象</a></li>
<li><a href="#14-java-%E6%95%B0%E7%BB%84%E5%92%8C%E5%86%85%E5%AD%98">1.4. Java 数组和内存</a></li>
</ul>
</li>
<li><a href="#2-%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84">2. 声明数组</a></li>
<li><a href="#3-%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84">3. 创建数组</a><ul>
<li><a href="#31-%E6%95%B0%E7%BB%84%E7%BB%B4%E5%BA%A6%E7%9A%84%E5%BD%A2%E5%BC%8F">3.1. 数组维度的形式</a></li>
<li><a href="#32-%E6%95%B0%E7%BB%84%E7%BB%B4%E5%BA%A6%E7%9A%84%E5%A4%A7%E5%B0%8F">3.2. 数组维度的大小</a></li>
</ul>
</li>
<li><a href="#4-%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84">4. 访问数组</a></li>
<li><a href="#5-%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%95%E7%94%A8">5. 数组的引用</a></li>
<li><a href="#6-%E6%B3%9B%E5%9E%8B%E5%92%8C%E6%95%B0%E7%BB%84">6. 泛型和数组</a></li>
<li><a href="#7-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">7. 多维数组</a></li>
<li><a href="#8-arrays-%E7%B1%BB">8. Arrays 类</a></li>
<li><a href="#9-%E5%B0%8F%E7%BB%93">9. 小结</a></li>
<li><a href="#10-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">10. 参考资料</a></li>
</ul>
<!-- /TOC -->

<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h3 id="1-1-数组的特性"><a href="#1-1-数组的特性" class="headerlink" title="1.1. 数组的特性"></a>1.1. 数组的特性</h3><p>数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。几乎所有程序设计语言都支持数组。</p>
<p>数组代表一系列对象或者基本数据类型，所有相同的类型都封装到一起，采用一个统一的标识符名称。</p>
<p><strong>数组的定义和使用需要通过方括号 <code>[]</code>。</strong></p>
<blockquote>
<p><strong>Java 中，数组是一种引用类型。</strong></p>
<p><strong>Java 中，数组是用来存储固定大小的同类型元素。</strong></p>
</blockquote>
<h3 id="1-2-数组和容器"><a href="#1-2-数组和容器" class="headerlink" title="1.2. 数组和容器"></a>1.2. 数组和容器</h3><p>Java 中，既然有了强大的容器，是不是就不需要数组了？</p>
<p>答案是不。</p>
<p>诚然，大多数情况下，应该选择容器存储数据。</p>
<p>但是，数组也不是毫无是处：</p>
<ul>
<li>Java 中，数组是一种效率最高的存储和随机访问对象引用序列的方式。<strong>数组的效率要高于容器</strong>（如 <code>ArrayList</code>）。</li>
<li><strong>数组可以持有值类型，而容器则不能</strong>（这时，就必须用到包装类）。</li>
</ul>
<h3 id="1-3-Java-数组的本质是对象"><a href="#1-3-Java-数组的本质是对象" class="headerlink" title="1.3. Java 数组的本质是对象"></a>1.3. Java 数组的本质是对象</h3><p><strong>Java 数组的本质是对象</strong>。它具有 Java 中其他对象的一些基本特点：封装了一些数据，可以访问属性，也可以调用方法。所以，数组是对象。</p>
<p>如果有两个类 A 和 B，如果 B 继承（extends）了 A，那么 A[] 类型的引用就可以指向 B[] 类型的对象。</p>
<blockquote>
<p>扩展阅读：<a href="https://blog.csdn.net/zhangjg_blog/article/details/16116613#t1">Java 中数组的特性</a></p>
<p>如果想要论证 <strong>Java 数组本质是对象</strong>，不妨一读这篇文章。</p>
</blockquote>
<h3 id="1-4-Java-数组和内存"><a href="#1-4-Java-数组和内存" class="headerlink" title="1.4. Java 数组和内存"></a>1.4. Java 数组和内存</h3><p>Java 数组在内存中的存储是这样的：</p>
<p>数组对象（这里可以看成一个指针）存储在栈中。</p>
<p>数组元素存储在堆中。</p>
<p>如下图所示：只有当 JVM 执行 <code>new String[]</code> 时，才会在堆中开辟相应的内存区域。数组对象 array 可以视为一个指针，指向这块内存的存储地址。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1552473482942.png" alt="img"></p>
<h2 id="2-声明数组"><a href="#2-声明数组" class="headerlink" title="2. 声明数组"></a>2. 声明数组</h2><p>声明数组变量的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1; <span class="comment">// 推荐风格</span></span><br><span class="line"><span class="keyword">int</span> arr2[]; <span class="comment">// 效果相同</span></span><br></pre></td></tr></table></figure>

<h2 id="3-创建数组"><a href="#3-创建数组" class="headerlink" title="3. 创建数组"></a>3. 创建数组</h2><p>Java 语言使用 <code>new</code> 操作符来创建数组。有两种创建数组方式：</p>
<ul>
<li>指定数组维度<ul>
<li>为数组开辟指定大小的数组维度。</li>
<li>如果数组元素是基础数据类型，会将每个元素设为默认值；如果是引用类型，元素值为 <code>null</code>。</li>
</ul>
</li>
<li>不指定数组维度<ul>
<li>用花括号中的实际元素初始化数组，数组大小与元素数相同。</li>
</ul>
</li>
</ul>
<p>示例 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]; <span class="comment">// 指定数组维度</span></span><br><span class="line">        <span class="keyword">int</span>[] array2 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;; <span class="comment">// 不指定数组维度</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;array1 size is &quot;</span> + array1.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item : array1) &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;array2 size is &quot;</span> + array1.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item : array2) &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// array1 size is 2</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// array2 size is 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 <strong>说明</strong><br>请注意数组 array1 中的元素虽然没有初始化，但是 length 和指定的数组维度是一样的。这表明<strong>指定数组维度后，无论后面是否初始化数组中的元素，数组都已经开辟了相应的内存</strong>。</p>
<p>数组 array1 中的元素都被设为默认值。</p>
</blockquote>
<p>示例 2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User[] array1 = <span class="keyword">new</span> User[<span class="number">2</span>]; <span class="comment">// 指定数组维度</span></span><br><span class="line">        User[] array2 = <span class="keyword">new</span> User[] &#123;<span class="keyword">new</span> User(), <span class="keyword">new</span> User()&#125;; <span class="comment">// 不指定数组维度</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;array1: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (User item : array1) &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;array2: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (User item : array2) &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// array1:</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// array2:</span></span><br><span class="line"><span class="comment">// io.github.dunwu.javacore.array.ArrayDemo2$User@4141d797</span></span><br><span class="line"><span class="comment">// io.github.dunwu.javacore.array.ArrayDemo2$User@68f7aae2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 <strong>说明</strong></p>
<p>请将本例与示例 1 比较，可以发现：如果使用指定数组维度方式创建数组，且数组元素为引用类型，则数组中的元素元素值为 <code>null</code>。</p>
</blockquote>
<h3 id="3-1-数组维度的形式"><a href="#3-1-数组维度的形式" class="headerlink" title="3.1. 数组维度的形式"></a>3.1. 数组维度的形式</h3><p>创建数组时，指定的数组维度可以有多种形式：</p>
<ul>
<li>数组维度可以是整数、字符。</li>
<li>数组维度可以是整数型、字符型变量。</li>
<li>数组维度可以是计算结果为整数或字符的表达式。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 放开被注掉的代码，编译器会报错</span></span><br><span class="line">        <span class="comment">// int[] array = new int[4.0];</span></span><br><span class="line">        <span class="comment">// int[] array2 = new int[&quot;test&quot;];</span></span><br><span class="line">        <span class="keyword">int</span>[] array3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">int</span>[] array4 = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span>[] array5 = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] array6 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="string">&#x27;a&#x27;</span> + <span class="number">2</span>];</span><br><span class="line">        <span class="comment">// int[] array7 = new int[length + 2.1];</span></span><br><span class="line">        System.out.println(<span class="string">&quot;array3.length = [&quot;</span> + array3.length + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;array4.length = [&quot;</span> + array4.length + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;array5.length = [&quot;</span> + array5.length + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;array6.length = [&quot;</span> + array6.length + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// array3.length = [97]</span></span><br><span class="line"><span class="comment">// array4.length = [3]</span></span><br><span class="line"><span class="comment">// array5.length = [5]</span></span><br><span class="line"><span class="comment">// array6.length = [99]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 <strong>说明</strong></p>
<p>当指定的数组维度是字符时，Java 会将其转为整数。如字符 <code>a</code> 的 ASCII 码是 97。</p>
<p>综上，<strong>Java 数组的数组维度可以是常量、变量、表达式，只要转换为整数即可</strong>。</p>
<p>请留意，有些编程语言则不支持这点，如 C/C++ 语言，只允许数组维度是常量。</p>
</blockquote>
<h3 id="3-2-数组维度的大小"><a href="#3-2-数组维度的大小" class="headerlink" title="3.2. 数组维度的大小"></a>3.2. 数组维度的大小</h3><p><strong>数组维度并非没有上限的，如果数值过大，编译时会报错。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6553612431</span>]; <span class="comment">// 数组维度过大，编译报错</span></span><br></pre></td></tr></table></figure>

<p>此外，<strong>数组过大，可能会导致栈溢出</strong>。</p>
<h2 id="4-访问数组"><a href="#4-访问数组" class="headerlink" title="4. 访问数组"></a>4. 访问数组</h2><p><strong>Java 中，可以通过在 <code>[]</code> 中指定下标，访问数组元素，下标位置从 0 开始。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i]++;</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;array[%d] = %d&quot;</span>, i, array[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// array[0] = 2</span></span><br><span class="line"><span class="comment">// array[1] = 3</span></span><br><span class="line"><span class="comment">// array[2] = 4</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 <strong>说明</strong></p>
<p>上面的示例中，从 0 开始，使用下标遍历数组 array 的所有元素，为每个元素值加 1 。</p>
</blockquote>
<h2 id="5-数组的引用"><a href="#5-数组的引用" class="headerlink" title="5. 数组的引用"></a>5. 数组的引用</h2><p><strong>Java 中，数组类型是一种引用类型</strong>。</p>
<p>因此，它可以作为引用，被 Java 函数<strong>作为函数入参或返回值</strong>。</p>
<p>数组作为函数入参的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayRefDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        fun(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 1	3	5</span></span><br></pre></td></tr></table></figure>

<p>数组作为函数返回值的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayRefDemo2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fun() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = fun();</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// [1, 3, 5]</span></span><br></pre></td></tr></table></figure>

<h2 id="6-泛型和数组"><a href="#6-泛型和数组" class="headerlink" title="6. 泛型和数组"></a>6. 泛型和数组</h2><p>通常，数组和泛型不能很好地结合。你不能实例化具有参数化类型的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Peel&lt;Banana&gt;[] peels = <span class="keyword">new</span> Pell&lt;Banana&gt;[<span class="number">10</span>]; <span class="comment">// 这行代码非法</span></span><br></pre></td></tr></table></figure>

<p>Java 中不允许直接创建泛型数组。但是，可以通过创建一个类型擦除的数组，然后转型的方式来创建泛型数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArrayDemo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">GenericArray</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            array = (T[]) <span class="keyword">new</span> Object[num];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, T item)</span> </span>&#123;</span><br><span class="line">            array[index] = item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123; <span class="keyword">return</span> array[index]; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T[] array() &#123; <span class="keyword">return</span> array; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GenericArray&lt;Integer&gt; genericArray = <span class="keyword">new</span> GenericArray&lt;Integer&gt;(<span class="number">4</span>);</span><br><span class="line">        genericArray.put(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        genericArray.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        Object[] array = genericArray.array();</span><br><span class="line">        System.out.println(Arrays.deepToString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// [0, 1, null, null]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展阅读：<a href="https://www.cnblogs.com/jiangzhaowei/p/7399522.html">https://www.cnblogs.com/jiangzhaowei/p/7399522.html</a></p>
<p>我认为，对于泛型数组的理解，点到为止即可。实际上，真的需要存储泛型，还是使用容器更合适。</p>
</blockquote>
<h2 id="7-多维数组"><a href="#7-多维数组" class="headerlink" title="7. 多维数组"></a>7. 多维数组</h2><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。</p>
<p>Java 可以支持二维数组、三维数组、四维数组、五维数组。。。</p>
<p>但是，以正常人的理解能力，一般也就最多能理解三维数组。所以，请不要做反人类的事，去定义过多维度的数组。</p>
<p>多维数组使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[][] a1 = &#123; <span class="comment">// 自动装箱</span></span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        Double[][][] a2 = &#123; <span class="comment">// 自动装箱</span></span><br><span class="line">            &#123; &#123;<span class="number">1.1</span>, <span class="number">2.2</span>&#125;, &#123;<span class="number">3.3</span>, <span class="number">4.4</span>&#125; &#125;,</span><br><span class="line">            &#123; &#123;<span class="number">5.5</span>, <span class="number">6.6</span>&#125;, &#123;<span class="number">7.7</span>, <span class="number">8.8</span>&#125; &#125;,</span><br><span class="line">            &#123; &#123;<span class="number">9.9</span>, <span class="number">1.2</span>&#125;, &#123;<span class="number">2.3</span>, <span class="number">3.4</span>&#125; &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        String[][] a3 = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;The&quot;</span>, <span class="string">&quot;Quick&quot;</span>, <span class="string">&quot;Sly&quot;</span>, <span class="string">&quot;Fox&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;Jumped&quot;</span>, <span class="string">&quot;Over&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;The&quot;</span>, <span class="string">&quot;Lazy&quot;</span>, <span class="string">&quot;Brown&quot;</span>, <span class="string">&quot;Dog&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;friend&quot;</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;a1: &quot;</span> + Arrays.deepToString(a1));</span><br><span class="line">        System.out.println(<span class="string">&quot;a2: &quot;</span> + Arrays.deepToString(a2));</span><br><span class="line">        System.out.println(<span class="string">&quot;a3: &quot;</span> + Arrays.deepToString(a3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// a1: [[1, 2, 3], [4, 5, 6]]</span></span><br><span class="line"><span class="comment">// a2: [[[1.1, 2.2], [3.3, 4.4]], [[5.5, 6.6], [7.7, 8.8]], [[9.9, 1.2], [2.3, 3.4]]]</span></span><br><span class="line"><span class="comment">// a3: [[The, Quick, Sly, Fox], [Jumped, Over], [The, Lazy, Brown, Dog, and, friend]]</span></span><br></pre></td></tr></table></figure>

<h2 id="8-Arrays-类"><a href="#8-Arrays-类" class="headerlink" title="8. Arrays 类"></a>8. Arrays 类</h2><p>Java 中，提供了一个很有用的数组工具类：Arrays。</p>
<p>它提供的主要操作有：</p>
<ul>
<li><code>sort</code> - 排序</li>
<li><code>binarySearch</code> - 查找</li>
<li><code>equals</code> - 比较</li>
<li><code>fill</code> - 填充</li>
<li><code>asList</code> - 转列表</li>
<li><code>hash</code> - 哈希</li>
<li><code>toString</code> - 转字符串</li>
</ul>
<blockquote>
<p>扩展阅读：<a href="https://juejin.im/post/5a6ade5c518825733e60acb8">https://juejin.im/post/5a6ade5c518825733e60acb8</a></p>
</blockquote>
<h2 id="9-小结"><a href="#9-小结" class="headerlink" title="9. 小结"></a>9. 小结</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1553753908349.png" alt="img"></p>
<h2 id="10-参考资料"><a href="#10-参考资料" class="headerlink" title="10. 参考资料"></a>10. 参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
<li><a href="https://blog.csdn.net/zhangjg_blog/article/details/16116613#t1">Java 中数组的特性</a></li>
<li><a href="https://juejin.im/post/59cae3de6fb9a00a4551915b">https://juejin.im/post/59cae3de6fb9a00a4551915b</a></li>
<li><a href="https://www.cnblogs.com/jiangzhaowei/p/7399522.html">https://www.cnblogs.com/jiangzhaowei/p/7399522.html</a></li>
<li><a href="https://juejin.im/post/5a6ade5c518825733e60acb8">https://juejin.im/post/5a6ade5c518825733e60acb8</a></li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Java 注解</title>
    <url>/2021/12/06/java-annotation/</url>
    <content><![CDATA[<h1 id="深入理解-Java-注解"><a href="#深入理解-Java-注解" class="headerlink" title="深入理解 Java 注解"></a>深入理解 Java 注解</h1><blockquote>
<p>本文内容基于 JDK8。注解是 JDK5 引入的，后续 JDK 版本扩展了一些内容，本文中没有明确指明版本的注解都是 JDK5 就已经支持的注解。</p>
<p><strong>📦 本文以及示例源码已归档在 <a href="https://github.com/dunwu/javacore/">javacore</a></strong></p>
</blockquote>
<!-- TOC depthFrom:2 depthTo:3 -->

<ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B">1. 简介</a><ul>
<li><a href="#11-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%BD%A2%E5%BC%8F">1.1. 注解的形式</a></li>
<li><a href="#12-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%A8%E8%A7%A3">1.2. 什么是注解</a></li>
<li><a href="#13-%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8">1.3. 注解的作用</a></li>
<li><a href="#14-%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BB%A3%E4%BB%B7">1.4. 注解的代价</a></li>
<li><a href="#15-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%BA%94%E7%94%A8%E8%8C%83%E5%9B%B4">1.5. 注解的应用范围</a></li>
</ul>
</li>
<li><a href="#2-%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3">2. 内置注解</a><ul>
<li><a href="#21-override">2.1. @Override</a></li>
<li><a href="#22-deprecated">2.2. @Deprecated</a></li>
<li><a href="#23-suppresswarnnings">2.3. @SuppressWarnnings</a></li>
<li><a href="#24-safevarargs">2.4. @SafeVarargs</a></li>
<li><a href="#25-functionalinterface">2.5. @FunctionalInterface</a></li>
</ul>
</li>
<li><a href="#3-%E5%85%83%E6%B3%A8%E8%A7%A3">3. 元注解</a><ul>
<li><a href="#31-retention">3.1. @Retention</a></li>
<li><a href="#32-documented">3.2. @Documented</a></li>
<li><a href="#33-target">3.3. @Target</a></li>
<li><a href="#34-inherited">3.4. @Inherited</a></li>
<li><a href="#35-repeatable">3.5. @Repeatable</a></li>
</ul>
</li>
<li><a href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3">4. 自定义注解</a><ul>
<li><a href="#41-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9A%E4%B9%89">4.1. 注解的定义</a></li>
<li><a href="#42-%E6%B3%A8%E8%A7%A3%E5%B1%9E%E6%80%A7">4.2. 注解属性</a></li>
<li><a href="#43-%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8">4.3. 注解处理器</a></li>
<li><a href="#44-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3">4.4. 使用注解</a></li>
</ul>
</li>
<li><a href="#5-%E5%B0%8F%E7%BB%93">5. 小结</a></li>
<li><a href="#6-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">6. 参考资料</a></li>
</ul>
<!-- /TOC -->

<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h3 id="1-1-注解的形式"><a href="#1-1-注解的形式" class="headerlink" title="1.1. 注解的形式"></a>1.1. 注解的形式</h3><p>Java 中，注解是以 <code>@</code> 字符开始的修饰符。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySuperMethod</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>注解可以包含命名或未命名的属性，并且这些属性有值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Author(</span></span><br><span class="line"><span class="meta">   name = &quot;Benjamin Franklin&quot;,</span></span><br><span class="line"><span class="meta">   date = &quot;3/27/2003&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>() </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>如果只有一个名为 value 的属性，那么名称可以省略，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>如果注解没有属性，则称为 <code>标记注解</code>。如：<code>@Override</code>。</p>
<h3 id="1-2-什么是注解"><a href="#1-2-什么是注解" class="headerlink" title="1.2. 什么是注解"></a>1.2. 什么是注解</h3><p>从本质上来说，<strong>注解是一种标签，其实质上可以视为一种特殊的注释，如果没有解析它的代码，它并不比普通注释强。</strong></p>
<p>解析一个注解往往有两种形式：</p>
<ul>
<li><strong>编译期直接的扫描</strong> - 编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。这种情况只适用于 JDK 内置的注解类。</li>
<li><strong>运行期的反射</strong> - 如果要自定义注解，Java 编译器无法识别并处理这个注解，它只能根据该注解的作用范围来选择是否编译进字节码文件。如果要处理注解，必须利用反射技术，识别该注解以及它所携带的信息，然后做相应的处理。</li>
</ul>
<h3 id="1-3-注解的作用"><a href="#1-3-注解的作用" class="headerlink" title="1.3. 注解的作用"></a>1.3. 注解的作用</h3><p>注解有许多用途：</p>
<ul>
<li>编译器信息 - 编译器可以使用注解来检测错误或抑制警告。</li>
<li>编译时和部署时的处理 - 程序可以处理注解信息以生成代码，XML 文件等。</li>
<li>运行时处理 - 可以在运行时检查某些注解并处理。</li>
</ul>
<p>作为 Java 程序员，多多少少都曾经历过被各种配置文件（xml、properties）支配的恐惧。过多的配置文件会使得项目难以维护。个人认为，使用注解以减少配置文件或代码，是注解最大的用处。</p>
<h3 id="1-4-注解的代价"><a href="#1-4-注解的代价" class="headerlink" title="1.4. 注解的代价"></a>1.4. 注解的代价</h3><p>凡事有得必有失，注解技术同样如此。使用注解也有一定的代价：</p>
<ul>
<li>显然，它是一种侵入式编程，那么，自然就存在着增加程序耦合度的问题。</li>
<li>自定义注解的处理需要在运行时，通过反射技术来获取属性。如果注解所修饰的元素是类的非 public 成员，也可以通过反射获取。这就违背了面向对象的封装性。</li>
<li>注解所产生的问题，相对而言，更难以 debug 或定位。</li>
</ul>
<p>但是，正所谓瑕不掩瑜，注解所付出的代价，相较于它提供的功能而言，还是可以接受的。</p>
<h3 id="1-5-注解的应用范围"><a href="#1-5-注解的应用范围" class="headerlink" title="1.5. 注解的应用范围"></a>1.5. 注解的应用范围</h3><p>注解可以应用于类、字段、方法和其他程序元素的声明。</p>
<p>JDK8 开始，注解的应用范围进一步扩大，以下是新的应用范围：</p>
<p>类实例初始化表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="meta">@Interned</span> MyObject();</span><br></pre></td></tr></table></figure>

<p>类型转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myString = (<span class="meta">@NonNull</span> String) str;</span><br></pre></td></tr></table></figure>

<p>实现接口的声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    @<span class="title">Readonly</span> <span class="title">List</span>&lt;@<span class="title">Readonly</span> <span class="title">T</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>抛出异常声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitorTemperature</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> @Critical TemperatureException </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-内置注解"><a href="#2-内置注解" class="headerlink" title="2. 内置注解"></a>2. 内置注解</h2><p>JDK 中内置了以下注解：</p>
<ul>
<li><code>@Override</code></li>
<li><code>@Deprecated</code></li>
<li><code>@SuppressWarnnings</code></li>
<li><code>@SafeVarargs</code>（JDK7 引入）</li>
<li><code>@FunctionalInterface</code>（JDK8 引入）</li>
</ul>
<h3 id="2-1-Override"><a href="#2-1-Override" class="headerlink" title="2.1. @Override"></a>2.1. @Override</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html"><code>@Override</code></a> 用于表明被修饰方法覆写了父类的方法。</strong></p>
<p>如果试图使用 <code>@Override</code> 标记一个实际上并没有覆写父类的方法时，java 编译器会告警。</p>
<p><code>@Override</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideAnnotationDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;getName&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;override getName&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  放开下面的注释，编译时会告警</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">        public String getName2() &#123;</span></span><br><span class="line"><span class="comment">            return &quot;override getName2&quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person per = <span class="keyword">new</span> Man();</span><br><span class="line">        System.out.println(per.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Deprecated"><a href="#2-2-Deprecated" class="headerlink" title="2.2. @Deprecated"></a>2.2. @Deprecated</h3><p><strong><code>@Deprecated</code> 用于标明被修饰的类或类成员、类方法已经废弃、过时，不建议使用。</strong></p>
<p><code>@Deprecated</code> 有一定的<strong>延续性</strong>：如果我们在代码中通过继承或者覆盖的方式使用了过时的类或类成员，即使子类或子方法没有标记为 <code>@Deprecated</code>，但编译器仍然会告警。</p>
<blockquote>
<p>🔔 注意： <code>@Deprecated</code> 这个注解类型和 javadoc 中的 <code>@deprecated</code> 这个 tag 是有区别的：前者是 java 编译器识别的；而后者是被 javadoc 工具所识别用来生成文档（包含程序成员为什么已经过时、它应当如何被禁止或者替代的描述）。</p>
</blockquote>
<p><code>@Deprecated</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeprecatedAnnotationDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeprecatedField</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Deprecated</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEPRECATED_FIELD = <span class="string">&quot;DeprecatedField&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeprecatedMethod</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Deprecated</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;DeprecatedMethod&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeprecatedClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;DeprecatedClass&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(DeprecatedField.DEPRECATED_FIELD);</span><br><span class="line"></span><br><span class="line">        DeprecatedMethod dm = <span class="keyword">new</span> DeprecatedMethod();</span><br><span class="line">        System.out.println(dm.print());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DeprecatedClass dc = <span class="keyword">new</span> DeprecatedClass();</span><br><span class="line">        System.out.println(dc.print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//DeprecatedField</span></span><br><span class="line"><span class="comment">//DeprecatedMethod</span></span><br><span class="line"><span class="comment">//DeprecatedClass</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-SuppressWarnnings"><a href="#2-3-SuppressWarnnings" class="headerlink" title="2.3. @SuppressWarnnings"></a>2.3. @SuppressWarnnings</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SuppressWarnings.html"><code>@SuppressWarnings</code></a> 用于关闭对类、方法、成员编译时产生的特定警告。</strong></p>
<p><code>@SuppressWarning</code> 不是一个标记注解。它有一个类型为 <code>String[]</code> 的数组成员，这个数组中存储的是要关闭的告警类型。对于 javac 编译器来讲，对 <code>-Xlint</code> 选项有效的警告名也同样对 <code>@SuppressWarings</code> 有效，同时编译器会忽略掉无法识别的警告名。</p>
<p><code>@SuppressWarning</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppressWarningsAnnotationDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppressDemo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="keyword">var</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;deprecation&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuppressDemo d = <span class="keyword">new</span> SuppressDemo();</span><br><span class="line">        d.setValue(<span class="string">&quot;南京&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;地名：&quot;</span> + d.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@SuppressWarnings</code> 注解的常见参数值的简单说明：</p>
<ul>
<li><code>deprecation</code> - 使用了不赞成使用的类或方法时的警告；</li>
<li><code>unchecked</code> - 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型;</li>
<li><code>fallthrough</code> - 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;</li>
<li><code>path</code> - 在类路径、源文件路径等中有不存在的路径时的警告;</li>
<li><code>serial</code> - 当在可序列化的类上缺少 serialVersionUID 定义时的警告;</li>
<li><code>finally</code> - 任何 finally 子句不能正常完成时的警告;</li>
<li><code>all</code> - 所有的警告。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;uncheck&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalAnnotationDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@SuppressWarnings</span> 标记消除当前类的告警信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;deprecation&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;call method1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Deprecated</span> 标记当前方法为废弃方法，不建议使用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Deprecated</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;call method2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Deprecated</span> 标记当前类为废弃类，不建议使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Override</span> 标记显示指明当前方法覆写了父类或接口的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A obj = <span class="keyword">new</span> B();</span><br><span class="line">        obj.method1();</span><br><span class="line">        obj.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-SafeVarargs"><a href="#2-4-SafeVarargs" class="headerlink" title="2.4. @SafeVarargs"></a>2.4. @SafeVarargs</h3><p><code>@SafeVarargs</code> 在 JDK7 中引入。</p>
<p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/SafeVarargs.html"><code>@SafeVarargs</code></a> 的作用是：告诉编译器，在可变长参数中的泛型是类型安全的。可变长参数是使用数组存储的，而数组和泛型不能很好的混合使用。</strong></p>
<p>简单的说，数组元素的数据类型在编译和运行时都是确定的，而泛型的数据类型只有在运行时才能确定下来。因此，当把一个泛型存储到数组中时，编译器在编译阶段无法确认数据类型是否匹配，因此会给出警告信息；即如果泛型的真实数据类型无法和参数数组的类型匹配，会导致 <code>ClassCastException</code> 异常。</p>
<p><code>@SafeVarargs</code> 注解使用范围：</p>
<ul>
<li><code>@SafeVarargs</code> 注解可以用于构造方法。</li>
<li><code>@SafeVarargs</code> 注解可以用于 <code>static</code> 或 <code>final</code> 方法。</li>
</ul>
<p><code>@SafeVarargs</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeVarargsAnnotationDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方法实际上并不安全，不使用此注解，编译时会告警</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrongMethod</span><span class="params">(List&lt;String&gt;... stringLists)</span> </span>&#123;</span><br><span class="line">        Object[] array = stringLists;</span><br><span class="line">        List&lt;Integer&gt; tmpList = Arrays.asList(<span class="number">42</span>);</span><br><span class="line">        array[<span class="number">0</span>] = tmpList; <span class="comment">// 语法错误，但是编译不告警</span></span><br><span class="line">        String s = stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// 运行时报 ClassCastException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        wrongMethod(list, list2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，如果不使用 <code>@SafeVarargs</code> ，编译时会告警</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[WARNING] /D:/Codes/ZP/Java/javacore/codes/basics/src/main/java/io/github/dunwu/javacore/annotation/SafeVarargsAnnotationDemo.java: 某些输入文件使用了未经检查或不安全的操作。</span><br><span class="line">[WARNING] /D:/Codes/ZP/Java/javacore/codes/basics/src/main/java/io/github/dunwu/javacore/annotation/SafeVarargsAnnotationDemo.java: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。</span><br></pre></td></tr></table></figure>

<h3 id="2-5-FunctionalInterface"><a href="#2-5-FunctionalInterface" class="headerlink" title="2.5. @FunctionalInterface"></a>2.5. @FunctionalInterface</h3><p><code>@FunctionalInterface</code> 在 JDK8 引入。</p>
<p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html"><code>@FunctionalInterface</code></a> 用于指示被修饰的接口是函数式接口。</strong></p>
<p>需要注意的是，如果一个接口符合”函数式接口”定义，不加 <code>@FunctionalInterface</code> 也没关系；但如果编写的不是函数式接口，却使用 <code>@FunctionInterface</code>，那么编译器会报错。</p>
<p>什么是函数式接口？</p>
<p><strong>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口</strong>。函数式接口可以被隐式转换为 lambda 表达式。</p>
<p>函数式接口的特点：</p>
<ul>
<li>接口有且只能有个一个抽象方法（抽象方法只有方法定义，没有方法体）。</li>
<li>不能在接口中覆写 Object 类中的 public 方法（写了编译器也会报错）。</li>
<li>允许有 default 实现方法。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterfaceAnnotationDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Func1</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(T message)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@FunctionalInterface</span> 修饰的接口中定义两个抽象方法，编译时会报错</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*@FunctionalInterface</span></span><br><span class="line"><span class="comment">    public interface Func2&lt;T&gt; &#123;</span></span><br><span class="line"><span class="comment">        void printMessage(T message);</span></span><br><span class="line"><span class="comment">        void printMessage2(T message);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Func1 func1 = message -&gt; System.out.println(message);</span><br><span class="line">        func1.printMessage(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        func1.printMessage(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-元注解"><a href="#3-元注解" class="headerlink" title="3. 元注解"></a>3. 元注解</h2><p>JDK 中虽然内置了几个注解，但这远远不能满足开发过程中遇到的千变万化的需求。所以我们需要自定义注解，而这就需要用到元注解。</p>
<p><strong>元注解的作用就是用于定义其它的注解</strong>。</p>
<p>Java 中提供了以下元注解类型：</p>
<ul>
<li><code>@Retention</code></li>
<li><code>@Target</code></li>
<li><code>@Documented</code></li>
<li><code>@Inherited</code>（JDK8 引入）</li>
<li><code>@Repeatable</code>（JDK8 引入）</li>
</ul>
<p>这些类型和它们所支持的类在 <code>java.lang.annotation</code> 包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。</p>
<h3 id="3-1-Retention"><a href="#3-1-Retention" class="headerlink" title="3.1. @Retention"></a>3.1. @Retention</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html"><code>@Retention</code></a> 指明了注解的保留级别。</strong></p>
<p><code>@Retention</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RetentionPolicy</code> 是一个枚举类型，它定义了被 <code>@Retention</code> 修饰的注解所支持的保留级别：</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code> - 标记的注解仅在源文件中有效，编译器会忽略。</li>
<li><code>RetentionPolicy.CLASS</code> - 标记的注解在 class 文件中有效，JVM 会忽略。</li>
<li><code>RetentionPolicy.RUNTIME</code> - 标记的注解在运行时有效。</li>
</ul>
<p><code>@Retention</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;fieldName&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setFuncName</span><span class="params">()</span> <span class="keyword">default</span> &quot;setField&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFuncName</span><span class="params">()</span> <span class="keyword">default</span> &quot;getField&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">defaultDBValue</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Documented"><a href="#3-2-Documented" class="headerlink" title="3.2. @Documented"></a>3.2. @Documented</h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Documented.html"><code>@Documented</code></a> 表示无论何时使用指定的注解，都应使用 Javadoc（默认情况下，注释不包含在 Javadoc 中）。更多内容可以参考：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/javadoc/index.html">Javadoc tools page</a>。</p>
<p><code>@Documented</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;fieldName&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setFuncName</span><span class="params">()</span> <span class="keyword">default</span> &quot;setField&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFuncName</span><span class="params">()</span> <span class="keyword">default</span> &quot;getField&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">defaultDBValue</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-Target"><a href="#3-3-Target" class="headerlink" title="3.3. @Target"></a>3.3. @Target</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html"><code>@Target</code></a> 指定注解可以修饰的元素类型。</strong></p>
<p><code>@Target</code> 源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ElementType</code> 是一个枚举类型，它定义了被 <code>@Target</code> 修饰的注解可以应用的范围：</p>
<ul>
<li><code>ElementType.ANNOTATION_TYPE</code> - 标记的注解可以应用于注解类型。</li>
<li><code>ElementType.CONSTRUCTOR</code> - 标记的注解可以应用于构造函数。</li>
<li><code>ElementType.FIELD</code> - 标记的注解可以应用于字段或属性。</li>
<li><code>ElementType.LOCAL_VARIABLE</code> - 标记的注解可以应用于局部变量。</li>
<li><code>ElementType.METHOD</code> - 标记的注解可以应用于方法。</li>
<li><code>ElementType.PACKAGE</code> - 标记的注解可以应用于包声明。</li>
<li><code>ElementType.PARAMETER</code> - 标记的注解可以应用于方法的参数。</li>
<li><code>ElementType.TYPE</code> - 标记的注解可以应用于类的任何元素。</li>
</ul>
<p><code>@Target</code> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据表名称注解，默认值为类名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tableName</span><span class="params">()</span> <span class="keyword">default</span> &quot;className&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NoDBColumn &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-Inherited"><a href="#3-4-Inherited" class="headerlink" title="3.4. @Inherited"></a>3.4. @Inherited</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html"><code>@Inherited</code></a> 表示注解类型可以被继承（默认情况下不是这样）</strong>。</p>
<p>表示自动继承注解类型。 如果注解类型声明中存在 <code>@Inherited</code> 元注解，则注解所修饰类的所有子类都将会继承此注解。</p>
<blockquote>
<p>🔔 注意：<code>@Inherited</code> 注解类型是被标注过的类的子类所继承。类并不从它所实现的接口继承注解，方法并不从它所覆写的方法继承注解。</p>
<p>此外，当 <code>@Inherited</code> 类型标注的注解的 <code>@Retention</code> 是 <code>RetentionPolicy.RUNTIME</code>，则反射 API 增强了这种继承性。如果我们使用 <code>java.lang.reflect</code> 去查询一个 <code>@Inherited</code> 类型的注解时，反射代码检查将展开工作：检查类和其父类，直到发现指定的注解类型被发现，或者到达类继承结构的顶层。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Greeting &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">FontColor</span></span>&#123; BULE,RED,GREEN&#125;;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">FontColor <span class="title">fontColor</span><span class="params">()</span> <span class="keyword">default</span> FontColor.GREEN</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-Repeatable"><a href="#3-5-Repeatable" class="headerlink" title="3.5. @Repeatable"></a>3.5. @Repeatable</h3><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Repeatable.html"><code>@Repeatable</code></a> 表示注解可以重复使用。</strong></p>
<p>以 Spring <code>@Scheduled</code> 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Schedules &#123;</span><br><span class="line">	Scheduled[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable(Schedules.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scheduled &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(&quot;0 0/15 * * * ?&quot;)</span></span><br><span class="line">    <span class="meta">@Scheduled(&quot;0 0 12 * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-自定义注解"><a href="#4-自定义注解" class="headerlink" title="4. 自定义注解"></a>4. 自定义注解</h2><p>使用 <code>@interface</code> 自定义注解时，自动继承了 <code>java.lang.annotation.Annotation</code> 接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。<code>@interface</code> 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过 <code>default</code> 来声明参数的默认值。</p>
<p>这里，我会通过实现一个名为 <code>RegexValid</code> 的正则校验注解工具来展示自定义注解的全步骤。</p>
<h3 id="4-1-注解的定义"><a href="#4-1-注解的定义" class="headerlink" title="4.1. 注解的定义"></a>4.1. 注解的定义</h3><p>注解的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名 &#123;定义体&#125;</span><br></pre></td></tr></table></figure>

<p>我们来定义一个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RegexValid &#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<p>通过上一节对于元注解 <a href="#target"><code>@Target</code></a>、<a href="#retention"><code>@Retention</code></a>、<a href="#documented"><code>@Documented</code></a> 的说明，这里就很容易理解了。</p>
<ul>
<li>上面的代码中定义了一个名为 <code>@RegexValid</code> 的注解。</li>
<li><code>@Documented</code> 表示 <code>@RegexValid</code> 应该使用 javadoc。</li>
<li><code>@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</code> 表示 <code>@RegexValid</code> 可以在类成员或方法参数上修饰。</li>
<li>@Retention(RetentionPolicy.RUNTIME) 表示 <code>@RegexValid</code> 在运行时有效。</li>
</ul>
</blockquote>
<p>此时，我们已经定义了一个没有任何属性的注解，如果到此为止，它仅仅是一个标记注解。作为正则工具，没有属性可什么也做不了。接下来，我们将为它添加注解属性。</p>
<h3 id="4-2-注解属性"><a href="#4-2-注解属性" class="headerlink" title="4.2. 注解属性"></a>4.2. 注解属性</h3><p>注解属性的语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[访问级别修饰符] [数据类型] 名称() default 默认值;</span><br></pre></td></tr></table></figure>

<p>例如，我们要定义在注解中定义一个名为 value 的字符串属性，其默认值为空字符串，访问级别为默认级别，那么应该定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String value() default &quot;&quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>🔔 注意：**在注解中，我们定义属性时，属性名后面需要加 <code>()</code>**。</p>
</blockquote>
<p>定义注解属性有以下要点：</p>
<ul>
<li><p><strong>注解属性只能使用 <code>public</code> 或默认访问级别（即不指定访问级别修饰符）修饰</strong>。</p>
</li>
<li><p><strong>注解属性的数据类型有限制要求</strong>。支持的数据类型如下：</p>
<ul>
<li>所有基本数据类型（byte、char、short、int、long、float、double、boolean）</li>
<li>String 类型</li>
<li>Class 类</li>
<li>enum 类型</li>
<li>Annotation 类型</li>
<li>以上所有类型的数组</li>
</ul>
</li>
<li><p><strong>注解属性必须有确定的值，建议指定默认值</strong>。注解属性只能通过指定默认值或使用注解时指定属性值，相较之下，指定默认值的方式更为可靠。注解属性如果是引用类型，不可以为 null。这个约束使得注解处理器很难判断注解属性是默认值，或是使用注解时所指定的属性值。为此，我们设置默认值时，一般会定义一些特殊的值，例如空字符串或者负数。</p>
</li>
<li><p>如果注解中只有一个属性值，最好将其命名为 value。因为，指定属性名为 value，在使用注解时，指定 value 的值可以不指定属性名称。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这两种方式效果相同</span></span><br><span class="line"><span class="meta">@RegexValid(&quot;^((\\+)?86\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\d&#123;8&#125;$&quot;)</span></span><br><span class="line"><span class="meta">@RegexValid(value = &quot;^((\\+)?86\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\d&#123;8&#125;$&quot;)</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>了解了注解属性的定义要点，让我们来为 <code>@RegexValid</code> 注解定义几个属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RegexValid &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Policy</span> </span>&#123;</span><br><span class="line">        <span class="comment">// @formatter:off</span></span><br><span class="line">        EMPTY(<span class="keyword">null</span>),</span><br><span class="line">        DATE(<span class="string">&quot;^(?:(?!0000)[0-9]&#123;4&#125;([-/.]?)(?:(?:0?[1-9]|1[0-2])\\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\\1&quot;</span></span><br><span class="line">            + <span class="string">&quot;(?:29|30)|(?:0?[13578]|1[02])\\1(?:31))|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|&quot;</span></span><br><span class="line">            + <span class="string">&quot;(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\\2(?:29))$&quot;</span>),</span><br><span class="line">        MAIL(<span class="string">&quot;^[A-Za-z0-9](([_\\.\\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\\.\\-]?[a-zA-Z0-9]+)*)\\.([A-Za-z]&#123;2,&#125;)$&quot;</span>);</span><br><span class="line">        <span class="comment">// @formatter:on</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String policy;</span><br><span class="line"></span><br><span class="line">        Policy(String policy) &#123;</span><br><span class="line">            <span class="keyword">this</span>.policy = policy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> policy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="function">Policy <span class="title">policy</span><span class="params">()</span> <span class="keyword">default</span> Policy.EMPTY</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<p>在上面的示例代码中，我们定义了两个注解属性：<code>String</code> 类型的 value 属性和 <code>Policy</code> 枚举类型的 policy 属性。<code>Policy</code> 枚举中定义了几个默认的正则表达式，这是为了直接使用这几个常用表达式去正则校验。考虑到，我们可能需要自己传入一些自定义正则表达式去校验其他场景，所以定义了 value 属性，允许使用者传入正则表达式。</p>
</blockquote>
<p>至此，<code>@RegexValid</code> 的声明已经结束。但是，程序仍不知道如何处理 <code>@RegexValid</code> 这个注解。我们还需要定义注解处理器。</p>
<h3 id="4-3-注解处理器"><a href="#4-3-注解处理器" class="headerlink" title="4.3. 注解处理器"></a>4.3. 注解处理器</h3><p>如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。JDK5 扩展了反射机制的 API，以帮助程序员快速的构造自定义注解处理器。</p>
<p><strong><code>java.lang.annotation.Annotation</code> 是一个接口，程序可以通过反射来获取指定程序元素的注解对象，然后通过注解对象来获取注解里面的元数据</strong>。</p>
<p><code>Annotation</code> 接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，Java 中支持<strong>注解处理器接口 <code>java.lang.reflect.AnnotatedElement</code></strong> ，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：</p>
<ul>
<li><code>Class</code> - 类定义</li>
<li><code>Constructor</code> - 构造器定义</li>
<li><code>Field</code> - 累的成员变量定义</li>
<li><code>Method</code> - 类的方法定义</li>
<li><code>Package</code> - 类的包定义</li>
</ul>
<p><code>java.lang.reflect</code> 包下主要包含一些实现反射功能的工具类。实际上，<code>java.lang.reflect</code> 包所有提供的反射 API 扩充了读取运行时注解信息的能力。当一个注解类型被定义为运行时的注解后，该注解才能是运行时可见，当 class 文件被装载时被保存在 class 文件中的注解才会被虚拟机读取。<br><code>AnnotatedElement</code> 接口是所有程序元素（Class、Method 和 Constructor）的父接口，所以程序通过反射获取了某个类的 <code>AnnotatedElement</code> 对象之后，程序就可以调用该对象的如下四个个方法来访问注解信息：</p>
<ul>
<li><code>getAnnotation</code> - 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回 null。</li>
<li><code>getAnnotations</code> - 返回该程序元素上存在的所有注解。</li>
<li><code>isAnnotationPresent</code> - 判断该程序元素上是否包含指定类型的注解，存在则返回 true，否则返回 false。</li>
<li><code>getDeclaredAnnotations</code> - 返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。</li>
</ul>
<p>了解了以上内容，让我们来实现 <code>@RegexValid</code> 的注解处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexValidUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Field[] fields = obj.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 判断成员是否被 @RegexValid 注解所修饰</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(RegexValid.class)) &#123;</span><br><span class="line">                RegexValid valid = field.getAnnotation(RegexValid.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 value 为空字符串，说明没有注入自定义正则表达式，改用 policy 属性</span></span><br><span class="line">                String value = valid.value();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(value)) &#123;</span><br><span class="line">                    RegexValid.Policy policy = valid.policy();</span><br><span class="line">                    value = policy.getPolicy();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过设置 setAccessible(true) 来访问私有成员</span></span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                Object fieldObj = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fieldObj = field.get(obj);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fieldObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                        .append(String.format(<span class="string">&quot;%s 类中的 %s 字段不能为空！&quot;</span>, obj.getClass().getName(), field.getName()));</span><br><span class="line">                    result = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fieldObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                        String text = (String) fieldObj;</span><br><span class="line">                        Pattern p = Pattern.compile(value);</span><br><span class="line">                        Matcher m = p.matcher(text);</span><br><span class="line">                        result = m.matches();</span><br><span class="line">                        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                            sb.append(<span class="string">&quot;\n&quot;</span>).append(String.format(<span class="string">&quot;%s 不是合法的 %s ！&quot;</span>, text, field.getName()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;\n&quot;</span>).append(</span><br><span class="line">                            String.format(<span class="string">&quot;%s 类中的 %s 字段不是字符串类型，不能使用此注解校验！&quot;</span>, obj.getClass().getName(), field.getName()));</span><br><span class="line">                        result = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sb.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：</p>
<p>以上示例中的注解处理器，执行步骤如下：</p>
<ol>
<li>通过 getDeclaredFields 反射方法获取传入对象的所有成员。</li>
<li>遍历成员，使用 isAnnotationPresent 判断成员是否被指定注解所修饰，如果不是，直接跳过。</li>
<li>如果成员被注解所修饰，通过 <code>RegexValid valid = field.getAnnotation(RegexValid.class);</code> 这样的形式获取，注解实例化对象，然后，就可以使用 <code>valid.value()</code> 或 <code>valid.policy()</code> 这样的形式获取注解中设定的属性值。</li>
<li>根据属性值，进行逻辑处理。</li>
</ol>
</blockquote>
<h3 id="4-4-使用注解"><a href="#4-4-使用注解" class="headerlink" title="4.4. 使用注解"></a>4.4. 使用注解</h3><p>完成了以上工作，我们就可以使用自定义注解了，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexValidDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="meta">@RegexValid(policy = RegexValid.Policy.DATE)</span></span><br><span class="line">        <span class="keyword">private</span> String date;</span><br><span class="line">        <span class="meta">@RegexValid(policy = RegexValid.Policy.MAIL)</span></span><br><span class="line">        <span class="keyword">private</span> String mail;</span><br><span class="line">        <span class="meta">@RegexValid(&quot;^((\\+)?86\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\d&#123;8&#125;$&quot;)</span></span><br><span class="line">        <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String date, String mail, String phone)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.date = date;</span><br><span class="line">            <span class="keyword">this</span>.mail = mail;</span><br><span class="line">            <span class="keyword">this</span>.phone = phone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, date=&#x27;&quot;</span> + date + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, mail=&#x27;&quot;</span> + mail + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, phone=&#x27;&quot;</span></span><br><span class="line">                + phone + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDate</span><span class="params">(<span class="meta">@RegexValid(policy = RegexValid.Policy.DATE)</span> String date)</span></span>&#123;</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;1990-01-31&quot;</span>, <span class="string">&quot;xxx@163.com&quot;</span>, <span class="string">&quot;18612341234&quot;</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;2019-02-29&quot;</span>, <span class="string">&quot;sadhgs&quot;</span>, <span class="string">&quot;183xxxxxxxx&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (RegexValidUtil.check(user)) &#123;</span><br><span class="line">            System.out.println(user + <span class="string">&quot;正则校验通过&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (RegexValidUtil.check(user2)) &#123;</span><br><span class="line">            System.out.println(user2 + <span class="string">&quot;正则校验通过&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/%E6%B3%A8%E8%A7%A3%E7%AE%80%E4%BB%8B.svg" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/%E5%85%83%E6%B3%A8%E8%A7%A3.svg" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3.svg" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/xmind/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3.svg" alt="img"></p>
<h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/2130190/">Java 编程思想</a></li>
<li><a href="https://book.douban.com/subject/3146174/">Java 核心技术（卷 1）</a></li>
<li><a href="https://book.douban.com/subject/3360807/">Effective java</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/annotations/">Oracle 官方文档之注解篇</a></li>
<li><a href="https://www.cnblogs.com/peida/archive/2013/04/24/3036689.html">深入理解 Java：注解（Annotation）自定义注解入门</a></li>
<li><a href="https://blog.csdn.net/briblue/article/details/73824058">https://blog.csdn.net/briblue/article/details/73824058</a></li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础特性</title>
    <url>/2021/12/06/java%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="Java-基础特性"><a href="#Java-基础特性" class="headerlink" title="Java 基础特性"></a>Java 基础特性</h1><blockquote>
<p>Java 基础篇总结 Java 的一些基础特性。</p>
</blockquote>
<h2 id="📖-内容"><a href="#📖-内容" class="headerlink" title="📖 内容"></a>📖 内容</h2><ul>
<li><a href="java-develop-env.md">Java 开发环境</a></li>
<li><a href="java-basic-grammar.md">Java 基础语法特性</a></li>
<li><a href="java-data-type.md">Java 基本数据类型</a></li>
<li><a href="java-string.md">Java String 类型</a></li>
<li><a href="java-oop.md">Java 面向对象</a></li>
<li><a href="java-method.md">Java 方法</a></li>
<li><a href="java-array.md">Java 数组</a></li>
<li><a href="java-enum.md">Java 枚举</a></li>
<li><a href="java-control-statement.md">Java 控制语句</a></li>
<li><a href="java-exception.md">Java 异常</a></li>
<li><a href="java-generic.md">Java 泛型</a></li>
<li><a href="java-reflection.md">Java 反射</a></li>
<li><a href="java-annotation.md">Java 注解</a></li>
</ul>
<h2 id="📚-资料"><a href="#📚-资料" class="headerlink" title="📚 资料"></a>📚 资料</h2><ul>
<li><strong>书籍</strong><ul>
<li>Java 四大名著<ul>
<li><a href="https://book.douban.com/subject/2130190/">《Java 编程思想（Thinking in java）》</a></li>
<li><a href="https://book.douban.com/subject/26880667/">《Java 核心技术 卷 I 基础知识》</a></li>
<li><a href="https://book.douban.com/subject/27165931/">《Java 核心技术 卷 II 高级特性》</a></li>
<li><a href="https://book.douban.com/subject/30412517/">《Effective Java》</a></li>
</ul>
</li>
<li>Java 并发<ul>
<li><a href="https://book.douban.com/subject/10484692/">《Java 并发编程实战》</a></li>
<li><a href="https://book.douban.com/subject/26591326/">《Java 并发编程的艺术》</a></li>
</ul>
</li>
<li>Java 虚拟机<ul>
<li><a href="https://book.douban.com/subject/34907497/">《深入理解 Java 虚拟机》</a></li>
</ul>
</li>
<li>Java 入门<ul>
<li><a href="https://book.douban.com/subject/2000732/">《O&#39;Reilly：Head First Java》</a></li>
<li><a href="https://book.douban.com/subject/3246499/">《疯狂 Java 讲义》</a></li>
</ul>
</li>
<li>其他<ul>
<li><a href="https://book.douban.com/subject/2243615/">《Head First 设计模式》</a></li>
<li><a href="https://book.douban.com/subject/1438754/">《Java 网络编程》</a></li>
<li><a href="https://book.douban.com/subject/25861566/">《Java 加密与解密的艺术》</a></li>
<li><a href="https://book.douban.com/subject/27605355/">《阿里巴巴 Java 开发手册》</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>教程、社区</strong><ul>
<li><a href="https://www.runoob.com/java/java-tutorial.html">Runoob Java 教程</a></li>
<li><a href="https://github.com/iluwatar/java-design-patterns">java-design-patterns</a></li>
<li><a href="https://github.com/TheAlgorithms/Java">Java</a></li>
<li><a href="https://time.geekbang.org/column/intro/82">《Java 核心技术面试精讲》</a></li>
<li><a href="https://time.geekbang.org/column/intro/100028001">《Java 性能调优实战》</a></li>
<li><a href="https://time.geekbang.org/column/intro/100047701">《Java 业务开发常见错误 100 例》</a></li>
<li><a href="https://time.geekbang.org/column/intro/100010301">深入拆解 Java 虚拟机</a></li>
<li><a href="https://time.geekbang.org/column/intro/100023901">《Java 并发编程实战》</a></li>
</ul>
</li>
<li><strong>面试</strong><ul>
<li><a href="https://github.com/CyC2018/CS-Notes">CS-Notes</a></li>
<li><a href="https://github.com/Snailclimb/JavaGuide">JavaGuide</a></li>
<li><a href="https://github.com/doocs/advanced-java">advanced-java</a></li>
</ul>
</li>
</ul>
<h2 id="🚪-传送"><a href="#🚪-传送" class="headerlink" title="🚪 传送"></a>🚪 传送</h2><p>◾ 🏠 <a href="https://github.com/dunwu/javacore">JAVACORE 首页</a> ◾ 🎯 <a href="https://github.com/dunwu/blog">我的博客</a> ◾</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>基础特性</tag>
      </tags>
  </entry>
  <entry>
    <title>《Java核心技术》第4章.对象与类</title>
    <url>/2021/12/06/OOP%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="OOP概述"><a href="#OOP概述" class="headerlink" title="OOP概述"></a>OOP概述</h1><h2 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h2><ul>
<li>类是构造对象的模板或蓝图</li>
<li>由类构造对象的过程成为创建类的实例</li>
<li>封装是处理对象的一个重要概念。</li>
<li>对象中的数据称为实例字段</li>
<li>操作数据的过程称为方法</li>
<li>作为一个类的实例，特定对象都有一组特定的实例字段值，这些值的集合就是这个对象的当前状态。</li>
</ul>
<h2 id="2-对象"><a href="#2-对象" class="headerlink" title="2.对象"></a>2.对象</h2><ul>
<li>对象的三个主要特征<ol>
<li>对象的行为</li>
<li>对象的状态</li>
<li>对象的标识</li>
</ol>
</li>
</ul>
<h2 id="3-识别类"><a href="#3-识别类" class="headerlink" title="3.识别类"></a>3.识别类</h2><ul>
<li>首先从识别类开始，然后再为各个类添加方法</li>
<li>分析问题的过程中寻找名词，而方法对应着动词</li>
</ul>
<h2 id="4-类之间的关系"><a href="#4-类之间的关系" class="headerlink" title="4.类之间的关系"></a>4.类之间的关系</h2><ul>
<li>依赖（uses-a）<br>如果一个类的方法使用或操纵另一个类的对象，我们就说一个类依赖于另一个类。<br>应该尽量将相互依赖的类减到最少，尽可能减少类之间的耦合。</li>
<li>聚合（has-a）<br>类A的对象包含类B的对象。</li>
<li>继承（is-a）<br>表示一个更特殊的类和一个更一般的类之间的关系。</li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown学习笔记</title>
    <url>/2021/12/04/%E5%AD%A6%E4%B9%A0markdown/</url>
    <content><![CDATA[<h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><h5 id="标题5"><a href="#标题5" class="headerlink" title="标题5"></a>标题5</h5><h6 id="标题6"><a href="#标题6" class="headerlink" title="标题6"></a>标题6</h6><blockquote>
<p>这是一段引用</p>
</blockquote>
<p>把大象放进冰箱：</p>
<ol>
<li>打开冰箱</li>
<li>把大象放进去</li>
<li>关上冰箱</li>
</ol>
<p>无序列表：</p>
<ul>
<li>111</li>
<li>222</li>
<li>333</li>
</ul>
<p>明天要做的事：</p>
<ul>
<li><input disabled="" type="checkbox"> 吃饭</li>
<li><input disabled="" type="checkbox"> 睡觉</li>
<li><input disabled="" type="checkbox"> 打豆豆</li>
</ul>
<p>代码块:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello,World!&quot;</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>数学公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E = mc^2</span><br></pre></td></tr></table></figure>

<p>表格：</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>年龄</th>
</tr>
</thead>
<tbody><tr>
<td>row 1 col 1</td>
<td>row 1 col 2</td>
</tr>
<tr>
<td>row 2 col 1</td>
<td>row 2 col 2</td>
</tr>
</tbody></table>
<p>脚注：<br>一键三连^[三连]</p>
<p>横线：</p>
<hr>
<p>链接：<br><a href="https://www.baidu.com/">百度</a></p>
<p>请参考<a href="#%E6%A0%87%E9%A2%981">标题1</a></p>
<p><em>斜体</em></p>
<p><strong>加粗</strong></p>
<p>H<del>2</del>O</p>
<p>X^2^</p>
<p>==这是一段高亮文字==</p>
<p><img src="" alt="图1"><a href="https://static01.imgkr.com/temp/ad944187032944ec863ce55134f3b37a.png%E2%80%9C%E5%9B%BE1%E2%80%9D">https://static01.imgkr.com/temp/ad944187032944ec863ce55134f3b37a.png“图1”</a>)<br><img src="" alt="图2"><a href="https://static01.imgkr.com/temp/16e89e377b844eec9376826b16baee22.png%E2%80%9C%E5%9B%BE2%E2%80%9D">https://static01.imgkr.com/temp/16e89e377b844eec9376826b16baee22.png“图2”</a>)</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>有道云笔记</tag>
      </tags>
  </entry>
</search>
